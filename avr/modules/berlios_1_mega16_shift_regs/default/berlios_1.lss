
berlios_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000fd4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000003c  00800060  00000fd4  00001068  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000001ad  0080009c  0080009c  000010a4  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  000010a4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00001770  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000120  00000000  00000000  000017f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000048b  00000000  00000000  00001915  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001d25  00000000  00000000  00001da0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000009a3  00000000  00000000  00003ac5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000014f8  00000000  00000000  00004468  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000330  00000000  00000000  00005960  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000baf  00000000  00000000  00005c90  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000010fe  00000000  00000000  0000683f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 000003d3  00000000  00000000  0000793d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 01 	jmp	0x254	; 0x254 <__ctors_end>
   4:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
   8:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
   c:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
  10:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
  14:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
  18:	0c 94 80 07 	jmp	0xf00	; 0xf00 <__vector_6>
  1c:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
  20:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
  24:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
  28:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
  2c:	0c 94 19 07 	jmp	0xe32	; 0xe32 <__vector_11>
  30:	0c 94 f2 06 	jmp	0xde4	; 0xde4 <__vector_12>
  34:	0c 94 40 07 	jmp	0xe80	; 0xe80 <__vector_13>
  38:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
  3c:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
  40:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
  44:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
  48:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
  4c:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>
  50:	0c 94 47 01 	jmp	0x28e	; 0x28e <__bad_interrupt>

00000054 <aucCRCHi>:
  54:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
  64:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
  74:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
  84:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
  94:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
  a4:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
  b4:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
  c4:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
  d4:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
  e4:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
  f4:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
 104:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
 114:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
 124:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
 134:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
 144:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@

00000154 <aucCRCLo>:
 154:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
 164:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
 174:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
 184:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
 194:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
 1a4:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
 1b4:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
 1c4:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
 1d4:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
 1e4:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
 1f4:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
 204:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
 214:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
 224:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
 234:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
 244:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

00000254 <__ctors_end>:
 254:	11 24       	eor	r1, r1
 256:	1f be       	out	0x3f, r1	; 63
 258:	cf e5       	ldi	r28, 0x5F	; 95
 25a:	d4 e0       	ldi	r29, 0x04	; 4
 25c:	de bf       	out	0x3e, r29	; 62
 25e:	cd bf       	out	0x3d, r28	; 61

00000260 <__do_copy_data>:
 260:	10 e0       	ldi	r17, 0x00	; 0
 262:	a0 e6       	ldi	r26, 0x60	; 96
 264:	b0 e0       	ldi	r27, 0x00	; 0
 266:	e4 ed       	ldi	r30, 0xD4	; 212
 268:	ff e0       	ldi	r31, 0x0F	; 15
 26a:	02 c0       	rjmp	.+4      	; 0x270 <__do_copy_data+0x10>
 26c:	05 90       	lpm	r0, Z+
 26e:	0d 92       	st	X+, r0
 270:	ac 39       	cpi	r26, 0x9C	; 156
 272:	b1 07       	cpc	r27, r17
 274:	d9 f7       	brne	.-10     	; 0x26c <__do_copy_data+0xc>

00000276 <__do_clear_bss>:
 276:	12 e0       	ldi	r17, 0x02	; 2
 278:	ac e9       	ldi	r26, 0x9C	; 156
 27a:	b0 e0       	ldi	r27, 0x00	; 0
 27c:	01 c0       	rjmp	.+2      	; 0x280 <.do_clear_bss_start>

0000027e <.do_clear_bss_loop>:
 27e:	1d 92       	st	X+, r1

00000280 <.do_clear_bss_start>:
 280:	a9 34       	cpi	r26, 0x49	; 73
 282:	b1 07       	cpc	r27, r17
 284:	e1 f7       	brne	.-8      	; 0x27e <.do_clear_bss_loop>
 286:	0e 94 97 01 	call	0x32e	; 0x32e <main>
 28a:	0c 94 e8 07 	jmp	0xfd0	; 0xfd0 <_exit>

0000028e <__bad_interrupt>:
 28e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000292 <reg_init>:

#define REGCOUNT 1
volatile static unsigned char reg_data[REGCOUNT];

void reg_init (){
	REGDDRPORT |= 0b01110000;
 292:	8a b3       	in	r24, 0x1a	; 26
 294:	80 67       	ori	r24, 0x70	; 112
 296:	8a bb       	out	0x1a, r24	; 26
	REGPORT &= 0b10001111;
 298:	8b b3       	in	r24, 0x1b	; 27
 29a:	8f 78       	andi	r24, 0x8F	; 143
 29c:	8b bb       	out	0x1b, r24	; 27
}
 29e:	08 95       	ret

000002a0 <reg_put_data>:

void reg_put_data(){
 2a0:	88 e0       	ldi	r24, 0x08	; 8
	
	for (char j = 0; j < REGCOUNT; j++){
		for (char i = 0; i < 8; i++){
			if (reg_data[j] & 0b10000000){ // 1
 2a2:	90 91 1f 01 	lds	r25, 0x011F
 2a6:	97 ff       	sbrs	r25, 7
 2a8:	02 c0       	rjmp	.+4      	; 0x2ae <reg_put_data+0xe>
				UPBIT(REGPORT, DATAPIN);				
 2aa:	de 9a       	sbi	0x1b, 6	; 27
 2ac:	01 c0       	rjmp	.+2      	; 0x2b0 <reg_put_data+0x10>
			}else{ //0
				DOWNBIT(REGPORT, DATAPIN);
 2ae:	de 98       	cbi	0x1b, 6	; 27
			}	
			UPBIT(REGPORT, CLOCK);
 2b0:	dc 9a       	sbi	0x1b, 4	; 27
			DOWNBIT(REGPORT, CLOCK);
 2b2:	dc 98       	cbi	0x1b, 4	; 27

			reg_data[j] = reg_data[j] << 1;
 2b4:	90 91 1f 01 	lds	r25, 0x011F
 2b8:	99 0f       	add	r25, r25
 2ba:	90 93 1f 01 	sts	0x011F, r25
 2be:	81 50       	subi	r24, 0x01	; 1
}

void reg_put_data(){
	
	for (char j = 0; j < REGCOUNT; j++){
		for (char i = 0; i < 8; i++){
 2c0:	81 f7       	brne	.-32     	; 0x2a2 <reg_put_data+0x2>
			DOWNBIT(REGPORT, CLOCK);

			reg_data[j] = reg_data[j] << 1;
		}
	}
	UPBIT(REGPORT, LATCH);
 2c2:	dd 9a       	sbi	0x1b, 5	; 27
	DOWNBIT(REGPORT, LATCH);
 2c4:	dd 98       	cbi	0x1b, 5	; 27
}
 2c6:	08 95       	ret

000002c8 <inreg_init>:

#define INREGCOUNT 3
volatile static unsigned char inreg_data[INREGCOUNT];

void inreg_init (){
	UPBIT(INREGDDRPORT, INLATCH);
 2c8:	a3 9a       	sbi	0x14, 3	; 20
	UPBIT(INREGDDRPORT, INCLOCK);
 2ca:	a4 9a       	sbi	0x14, 4	; 20

	UPBIT(INREGPORT, INLATCH);
 2cc:	ab 9a       	sbi	0x15, 3	; 21
	DOWNBIT(INREGPORT, INCLOCK);
 2ce:	ac 98       	cbi	0x15, 4	; 21
}
 2d0:	08 95       	ret

000002d2 <inreg_get_data>:

unsigned char inreg_get_data(unsigned char position){
	
	DOWNBIT(INREGPORT, INLATCH);
 2d2:	ab 98       	cbi	0x15, 3	; 21
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2d4:	a8 e2       	ldi	r26, 0x28	; 40
 2d6:	b2 e0       	ldi	r27, 0x02	; 2
 2d8:	11 97       	sbiw	r26, 0x01	; 1
 2da:	f1 f7       	brne	.-4      	; 0x2d8 <inreg_get_data+0x6>
 2dc:	00 c0       	rjmp	.+0      	; 0x2de <inreg_get_data+0xc>
 2de:	00 00       	nop
	_delay_us(300);
	UPBIT(INREGPORT, INLATCH);
 2e0:	ab 9a       	sbi	0x15, 3	; 21
 2e2:	20 e0       	ldi	r18, 0x00	; 0
 2e4:	30 e0       	ldi	r19, 0x00	; 0
	unsigned char data = 0;

	for (char j = 0; j < INREGCOUNT; j++){
		inreg_data[j] = 0;
 2e6:	f9 01       	movw	r30, r18
 2e8:	e4 5e       	subi	r30, 0xE4	; 228
 2ea:	fe 4f       	sbci	r31, 0xFE	; 254
 2ec:	10 82       	st	Z, r1
 2ee:	48 e0       	ldi	r20, 0x08	; 8
		for (char i = 0; i < 8; i++){
			inreg_data[j] = inreg_data[j] << 1;
 2f0:	90 81       	ld	r25, Z
 2f2:	99 0f       	add	r25, r25
 2f4:	90 83       	st	Z, r25
			inreg_data[j] += (PINC >> INDATAPIN) & 0b00000001; 
 2f6:	50 81       	ld	r21, Z
 2f8:	93 b3       	in	r25, 0x13	; 19
 2fa:	92 95       	swap	r25
 2fc:	96 95       	lsr	r25
 2fe:	91 70       	andi	r25, 0x01	; 1
 300:	59 0f       	add	r21, r25
 302:	50 83       	st	Z, r21
			DOWNBIT(INREGPORT, INCLOCK);
 304:	ac 98       	cbi	0x15, 4	; 21
 306:	a8 e2       	ldi	r26, 0x28	; 40
 308:	b2 e0       	ldi	r27, 0x02	; 2
 30a:	11 97       	sbiw	r26, 0x01	; 1
 30c:	f1 f7       	brne	.-4      	; 0x30a <inreg_get_data+0x38>
 30e:	00 c0       	rjmp	.+0      	; 0x310 <inreg_get_data+0x3e>
 310:	00 00       	nop
			_delay_us(300);
			UPBIT(INREGPORT, INCLOCK);
 312:	ac 9a       	sbi	0x15, 4	; 21
 314:	41 50       	subi	r20, 0x01	; 1
	UPBIT(INREGPORT, INLATCH);
	unsigned char data = 0;

	for (char j = 0; j < INREGCOUNT; j++){
		inreg_data[j] = 0;
		for (char i = 0; i < 8; i++){
 316:	61 f7       	brne	.-40     	; 0x2f0 <inreg_get_data+0x1e>
 318:	2f 5f       	subi	r18, 0xFF	; 255
 31a:	3f 4f       	sbci	r19, 0xFF	; 255
	DOWNBIT(INREGPORT, INLATCH);
	_delay_us(300);
	UPBIT(INREGPORT, INLATCH);
	unsigned char data = 0;

	for (char j = 0; j < INREGCOUNT; j++){
 31c:	23 30       	cpi	r18, 0x03	; 3
 31e:	31 05       	cpc	r19, r1
 320:	11 f7       	brne	.-60     	; 0x2e6 <inreg_get_data+0x14>
			_delay_us(300);
			UPBIT(INREGPORT, INCLOCK);
		}
	}

	return inreg_data[position];
 322:	e8 2f       	mov	r30, r24
 324:	f0 e0       	ldi	r31, 0x00	; 0
 326:	e4 5e       	subi	r30, 0xE4	; 228
 328:	fe 4f       	sbci	r31, 0xFE	; 254
 32a:	80 81       	ld	r24, Z
}
 32c:	08 95       	ret

0000032e <main>:

int
main( void )
{
 32e:	ef 92       	push	r14
 330:	0f 93       	push	r16
 332:	1f 93       	push	r17

reg_init();
 334:	0e 94 49 01 	call	0x292	; 0x292 <reg_init>
inreg_init ();
 338:	0e 94 64 01 	call	0x2c8	; 0x2c8 <inreg_init>


    const UCHAR     ucSlaveID[] = { 0xAA, 0xBB, 0xCC };
    eMBErrorCode    eStatus;

    eStatus = eMBInit( MB_RTU, CLIENT_ID, 0, BAUDRATE, MB_PAR_NONE );
 33c:	80 e0       	ldi	r24, 0x00	; 0
 33e:	6a e0       	ldi	r22, 0x0A	; 10
 340:	40 e0       	ldi	r20, 0x00	; 0
 342:	00 e0       	ldi	r16, 0x00	; 0
 344:	16 e9       	ldi	r17, 0x96	; 150
 346:	20 e0       	ldi	r18, 0x00	; 0
 348:	30 e0       	ldi	r19, 0x00	; 0
 34a:	ee 24       	eor	r14, r14
 34c:	0e 94 04 02 	call	0x408	; 0x408 <eMBInit>

    //eStatus = eMBSetSlaveID( 0x34, TRUE, ucSlaveID, 3 );
    sei(  );
 350:	78 94       	sei

    /* Enable the Modbus Protocol Stack. */
    eStatus = eMBEnable(  );
 352:	0e 94 b2 02 	call	0x564	; 0x564 <eMBEnable>

    for( ;; )
    {
		g_reg_holding_device[1] = inreg_get_data(0);
 356:	80 e0       	ldi	r24, 0x00	; 0
 358:	0e 94 69 01 	call	0x2d2	; 0x2d2 <inreg_get_data>
 35c:	80 93 9d 00 	sts	0x009D, r24
		g_reg_holding_device[2] = inreg_data[1];
 360:	80 91 1d 01 	lds	r24, 0x011D
 364:	80 93 9e 00 	sts	0x009E, r24
		g_reg_holding_device[3] = inreg_data[2];
 368:	80 91 1e 01 	lds	r24, 0x011E
 36c:	80 93 9f 00 	sts	0x009F, r24


        ( void )eMBPoll(  );
 370:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <eMBPoll>

        /* Here we simply count the number of poll cycles. */
        g_reg_holding_device[0]++;
 374:	80 91 9c 00 	lds	r24, 0x009C
 378:	8f 5f       	subi	r24, 0xFF	; 255
 37a:	80 93 9c 00 	sts	0x009C, r24

		if (g_reg_holding_data[1] != 0){
 37e:	80 91 a1 00 	lds	r24, 0x00A1
 382:	88 23       	and	r24, r24
 384:	41 f3       	breq	.-48     	; 0x356 <main+0x28>
			reg_data[0] = g_reg_holding_data[1];
 386:	80 91 a1 00 	lds	r24, 0x00A1
 38a:	80 93 1f 01 	sts	0x011F, r24
			reg_put_data();
 38e:	0e 94 50 01 	call	0x2a0	; 0x2a0 <reg_put_data>
			g_reg_holding_data[1] = 0;
 392:	10 92 a1 00 	sts	0x00A1, r1
 396:	df cf       	rjmp	.-66     	; 0x356 <main+0x28>

00000398 <eMBRegHoldingCB>:


  eMBErrorCode  eStatus = MB_ENOERR;

	// READ REGESTERS
	if (eMode == MB_REG_READ){
 398:	22 23       	and	r18, r18
 39a:	b1 f4       	brne	.+44     	; 0x3c8 <eMBRegHoldingCB+0x30>
		if (( usAddress == REG_HOLDING_START ) && 
 39c:	6a 30       	cpi	r22, 0x0A	; 10
 39e:	71 05       	cpc	r23, r1
 3a0:	89 f5       	brne	.+98     	; 0x404 <eMBRegHoldingCB+0x6c>
 3a2:	42 30       	cpi	r20, 0x02	; 2
 3a4:	51 05       	cpc	r21, r1
 3a6:	71 f5       	brne	.+92     	; 0x404 <eMBRegHoldingCB+0x6c>
 3a8:	40 e0       	ldi	r20, 0x00	; 0
 3aa:	09 c0       	rjmp	.+18     	; 0x3be <eMBRegHoldingCB+0x26>
			// test debug
//			if (g_reg_holding_device[2]++ == 255)
//				g_reg_holding_device[3]++;

			for (char i = 0; i < usNRegs * 2; i++){
				pucRegBuffer[i] = g_reg_holding_device[i];
 3ac:	f9 01       	movw	r30, r18
 3ae:	e4 56       	subi	r30, 0x64	; 100
 3b0:	ff 4f       	sbci	r31, 0xFF	; 255
 3b2:	50 81       	ld	r21, Z
 3b4:	28 0f       	add	r18, r24
 3b6:	39 1f       	adc	r19, r25
 3b8:	f9 01       	movw	r30, r18
 3ba:	50 83       	st	Z, r21

			// test debug
//			if (g_reg_holding_device[2]++ == 255)
//				g_reg_holding_device[3]++;

			for (char i = 0; i < usNRegs * 2; i++){
 3bc:	4f 5f       	subi	r20, 0xFF	; 255
 3be:	24 2f       	mov	r18, r20
 3c0:	30 e0       	ldi	r19, 0x00	; 0
 3c2:	44 30       	cpi	r20, 0x04	; 4
 3c4:	99 f7       	brne	.-26     	; 0x3ac <eMBRegHoldingCB+0x14>
 3c6:	1a c0       	rjmp	.+52     	; 0x3fc <eMBRegHoldingCB+0x64>
			eStatus = MB_ENORES;
		}
	}

	// WRITE REGESTERS
	if (eMode == MB_REG_WRITE){
 3c8:	21 30       	cpi	r18, 0x01	; 1
 3ca:	c1 f4       	brne	.+48     	; 0x3fc <eMBRegHoldingCB+0x64>
		if (( usAddress == REG_HOLDING_DATA_START ) && 
 3cc:	64 31       	cpi	r22, 0x14	; 20
 3ce:	71 05       	cpc	r23, r1
 3d0:	c9 f4       	brne	.+50     	; 0x404 <eMBRegHoldingCB+0x6c>
 3d2:	4f 33       	cpi	r20, 0x3F	; 63
 3d4:	51 05       	cpc	r21, r1
 3d6:	a0 f4       	brcc	.+40     	; 0x400 <eMBRegHoldingCB+0x68>
			( usNRegs <= REG_HOLDING_DATA_NREGS)){

			for (char i = 0; i < usNRegs * 2; i++){
 3d8:	44 0f       	add	r20, r20
 3da:	55 1f       	adc	r21, r21
 3dc:	60 e0       	ldi	r22, 0x00	; 0
 3de:	09 c0       	rjmp	.+18     	; 0x3f2 <eMBRegHoldingCB+0x5a>
				g_reg_holding_data[i] = pucRegBuffer[i];
 3e0:	fc 01       	movw	r30, r24
 3e2:	e2 0f       	add	r30, r18
 3e4:	f3 1f       	adc	r31, r19
 3e6:	70 81       	ld	r23, Z
 3e8:	20 56       	subi	r18, 0x60	; 96
 3ea:	3f 4f       	sbci	r19, 0xFF	; 255
 3ec:	f9 01       	movw	r30, r18
 3ee:	70 83       	st	Z, r23
	// WRITE REGESTERS
	if (eMode == MB_REG_WRITE){
		if (( usAddress == REG_HOLDING_DATA_START ) && 
			( usNRegs <= REG_HOLDING_DATA_NREGS)){

			for (char i = 0; i < usNRegs * 2; i++){
 3f0:	6f 5f       	subi	r22, 0xFF	; 255
 3f2:	26 2f       	mov	r18, r22
 3f4:	30 e0       	ldi	r19, 0x00	; 0
 3f6:	24 17       	cp	r18, r20
 3f8:	35 07       	cpc	r19, r21
 3fa:	90 f3       	brcs	.-28     	; 0x3e0 <eMBRegHoldingCB+0x48>
                 eMBRegisterMode eMode )
{



  eMBErrorCode  eStatus = MB_ENOERR;
 3fc:	80 e0       	ldi	r24, 0x00	; 0
 3fe:	08 95       	ret

			for (char i = 0; i < usNRegs * 2; i++){
				g_reg_holding_data[i] = pucRegBuffer[i];
			}
		}else{
			eStatus = MB_ENORES;
 400:	84 e0       	ldi	r24, 0x04	; 4
		}
	}

  return eStatus;
}
 402:	08 95       	ret

			for (char i = 0; i < usNRegs * 2; i++){
				pucRegBuffer[i] = g_reg_holding_device[i];
			}
		}else{
			eStatus = MB_ENORES;
 404:	84 e0       	ldi	r24, 0x04	; 4
 406:	08 95       	ret

00000408 <eMBInit>:
};

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBInit( eMBMode eMode, UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
 408:	ef 92       	push	r14
 40a:	0f 93       	push	r16
 40c:	1f 93       	push	r17
 40e:	98 2f       	mov	r25, r24
 410:	86 2f       	mov	r24, r22
 412:	64 2f       	mov	r22, r20
 414:	a9 01       	movw	r20, r18
 416:	98 01       	movw	r18, r16
 418:	0e 2d       	mov	r16, r14
    eMBErrorCode    eStatus = MB_ENOERR;

    /* check preconditions */
    if( ( ucSlaveAddress == MB_ADDRESS_BROADCAST ) ||
        ( ucSlaveAddress < MB_ADDRESS_MIN ) || ( ucSlaveAddress > MB_ADDRESS_MAX ) )
 41a:	78 2f       	mov	r23, r24
 41c:	71 50       	subi	r23, 0x01	; 1
eMBInit( eMBMode eMode, UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
    eMBErrorCode    eStatus = MB_ENOERR;

    /* check preconditions */
    if( ( ucSlaveAddress == MB_ADDRESS_BROADCAST ) ||
 41e:	77 3f       	cpi	r23, 0xF7	; 247
 420:	08 f0       	brcs	.+2      	; 0x424 <eMBInit+0x1c>
 422:	41 c0       	rjmp	.+130    	; 0x4a6 <__stack+0x47>
    {
        eStatus = MB_EINVAL;
    }
    else
    {
        ucMBAddress = ucSlaveAddress;
 424:	80 93 22 01 	sts	0x0122, r24

        switch ( eMode )
 428:	99 23       	and	r25, r25
 42a:	e9 f5       	brne	.+122    	; 0x4a6 <__stack+0x47>
        {
#if MB_RTU_ENABLED > 0
        case MB_RTU:
            pvMBFrameStartCur = eMBRTUStart;
 42c:	e2 ee       	ldi	r30, 0xE2	; 226
 42e:	f4 e0       	ldi	r31, 0x04	; 4
 430:	f0 93 2f 01 	sts	0x012F, r31
 434:	e0 93 2e 01 	sts	0x012E, r30
            pvMBFrameStopCur = eMBRTUStop;
 438:	ed ee       	ldi	r30, 0xED	; 237
 43a:	f4 e0       	ldi	r31, 0x04	; 4
 43c:	f0 93 2d 01 	sts	0x012D, r31
 440:	e0 93 2c 01 	sts	0x012C, r30
            peMBFrameSendCur = eMBRTUSend;
 444:	ec e2       	ldi	r30, 0x2C	; 44
 446:	f5 e0       	ldi	r31, 0x05	; 5
 448:	f0 93 24 01 	sts	0x0124, r31
 44c:	e0 93 23 01 	sts	0x0123, r30
            peMBFrameReceiveCur = eMBRTUReceive;
 450:	e6 ef       	ldi	r30, 0xF6	; 246
 452:	f4 e0       	ldi	r31, 0x04	; 4
 454:	f0 93 21 01 	sts	0x0121, r31
 458:	e0 93 20 01 	sts	0x0120, r30
            pvMBFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBPortClose : NULL;
 45c:	10 92 31 01 	sts	0x0131, r1
 460:	10 92 30 01 	sts	0x0130, r1
            pxMBFrameCBByteReceived = xMBRTUReceiveFSM;
 464:	e9 e7       	ldi	r30, 0x79	; 121
 466:	f5 e0       	ldi	r31, 0x05	; 5
 468:	f0 93 44 01 	sts	0x0144, r31
 46c:	e0 93 43 01 	sts	0x0143, r30
            pxMBFrameCBTransmitterEmpty = xMBRTUTransmitFSM;
 470:	e2 ec       	ldi	r30, 0xC2	; 194
 472:	f5 e0       	ldi	r31, 0x05	; 5
 474:	f0 93 40 01 	sts	0x0140, r31
 478:	e0 93 3f 01 	sts	0x013F, r30
            pxMBPortCBTimerExpired = xMBRTUTimerT35Expired;
 47c:	ee ef       	ldi	r30, 0xFE	; 254
 47e:	f5 e0       	ldi	r31, 0x05	; 5
 480:	f0 93 42 01 	sts	0x0142, r31
 484:	e0 93 41 01 	sts	0x0141, r30

            eStatus = eMBRTUInit( ucMBAddress, ucPort, ulBaudRate, eParity );
 488:	0e 94 a9 04 	call	0x952	; 0x952 <eMBRTUInit>
 48c:	08 2f       	mov	r16, r24
#endif
        default:
            eStatus = MB_EINVAL;
        }

        if( eStatus == MB_ENOERR )
 48e:	88 23       	and	r24, r24
 490:	69 f4       	brne	.+26     	; 0x4ac <__stack+0x4d>
        {
            if( !xMBPortEventInit(  ) )
 492:	0e 94 83 06 	call	0xd06	; 0xd06 <xMBPortEventInit>
 496:	88 23       	and	r24, r24
 498:	41 f0       	breq	.+16     	; 0x4aa <__stack+0x4b>
                /* port dependent event module initalization failed. */
                eStatus = MB_EPORTERR;
            }
            else
            {
                eMBCurrentMode = eMode;
 49a:	10 92 32 01 	sts	0x0132, r1
                eMBState = STATE_DISABLED;
 49e:	81 e0       	ldi	r24, 0x01	; 1
 4a0:	80 93 60 00 	sts	0x0060, r24
 4a4:	03 c0       	rjmp	.+6      	; 0x4ac <__stack+0x4d>

            eStatus = eMBASCIIInit( ucMBAddress, ucPort, ulBaudRate, eParity );
            break;
#endif
        default:
            eStatus = MB_EINVAL;
 4a6:	02 e0       	ldi	r16, 0x02	; 2
 4a8:	01 c0       	rjmp	.+2      	; 0x4ac <__stack+0x4d>
        if( eStatus == MB_ENOERR )
        {
            if( !xMBPortEventInit(  ) )
            {
                /* port dependent event module initalization failed. */
                eStatus = MB_EPORTERR;
 4aa:	03 e0       	ldi	r16, 0x03	; 3
                eMBState = STATE_DISABLED;
            }
        }
    }
    return eStatus;
}
 4ac:	80 2f       	mov	r24, r16
 4ae:	1f 91       	pop	r17
 4b0:	0f 91       	pop	r16
 4b2:	ef 90       	pop	r14
 4b4:	08 95       	ret

000004b6 <eMBRegisterCB>:
eMBRegisterCB( UCHAR ucFunctionCode, pxMBFunctionHandler pxHandler )
{
    int             i;
    eMBErrorCode    eStatus;

    if( ( 0 < ucFunctionCode ) && ( ucFunctionCode <= 127 ) )
 4b6:	18 16       	cp	r1, r24
 4b8:	0c f0       	brlt	.+2      	; 0x4bc <eMBRegisterCB+0x6>
 4ba:	41 c0       	rjmp	.+130    	; 0x53e <eMBRegisterCB+0x88>
    {
        ENTER_CRITICAL_SECTION(  );
 4bc:	f8 94       	cli
        if( pxHandler != NULL )
 4be:	61 15       	cp	r22, r1
 4c0:	71 05       	cpc	r23, r1
 4c2:	11 f1       	breq	.+68     	; 0x508 <eMBRegisterCB+0x52>
 4c4:	e2 e6       	ldi	r30, 0x62	; 98
 4c6:	f0 e0       	ldi	r31, 0x00	; 0
 4c8:	20 e0       	ldi	r18, 0x00	; 0
 4ca:	30 e0       	ldi	r19, 0x00	; 0
        {
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
            {
                if( ( xFuncHandlers[i].pxHandler == NULL ) ||
 4cc:	40 81       	ld	r20, Z
 4ce:	51 81       	ldd	r21, Z+1	; 0x01
 4d0:	41 15       	cp	r20, r1
 4d2:	51 05       	cpc	r21, r1
 4d4:	19 f0       	breq	.+6      	; 0x4dc <eMBRegisterCB+0x26>
 4d6:	46 17       	cp	r20, r22
 4d8:	57 07       	cpc	r21, r23
 4da:	71 f4       	brne	.+28     	; 0x4f8 <eMBRegisterCB+0x42>
                    ( xFuncHandlers[i].pxHandler == pxHandler ) )
                {
                    xFuncHandlers[i].ucFunctionCode = ucFunctionCode;
 4dc:	f9 01       	movw	r30, r18
 4de:	ee 0f       	add	r30, r30
 4e0:	ff 1f       	adc	r31, r31
 4e2:	e2 0f       	add	r30, r18
 4e4:	f3 1f       	adc	r31, r19
 4e6:	ef 59       	subi	r30, 0x9F	; 159
 4e8:	ff 4f       	sbci	r31, 0xFF	; 255
 4ea:	80 83       	st	Z, r24
                    xFuncHandlers[i].pxHandler = pxHandler;
 4ec:	72 83       	std	Z+2, r23	; 0x02
 4ee:	61 83       	std	Z+1, r22	; 0x01
                    break;
                }
            }
            eStatus = ( i != MB_FUNC_HANDLERS_MAX ) ? MB_ENOERR : MB_ENORES;
 4f0:	20 31       	cpi	r18, 0x10	; 16
 4f2:	31 05       	cpc	r19, r1
 4f4:	09 f5       	brne	.+66     	; 0x538 <eMBRegisterCB+0x82>
 4f6:	06 c0       	rjmp	.+12     	; 0x504 <eMBRegisterCB+0x4e>
    if( ( 0 < ucFunctionCode ) && ( ucFunctionCode <= 127 ) )
    {
        ENTER_CRITICAL_SECTION(  );
        if( pxHandler != NULL )
        {
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
 4f8:	2f 5f       	subi	r18, 0xFF	; 255
 4fa:	3f 4f       	sbci	r19, 0xFF	; 255
 4fc:	33 96       	adiw	r30, 0x03	; 3
 4fe:	20 31       	cpi	r18, 0x10	; 16
 500:	31 05       	cpc	r19, r1
 502:	21 f7       	brne	.-56     	; 0x4cc <eMBRegisterCB+0x16>
                    xFuncHandlers[i].ucFunctionCode = ucFunctionCode;
                    xFuncHandlers[i].pxHandler = pxHandler;
                    break;
                }
            }
            eStatus = ( i != MB_FUNC_HANDLERS_MAX ) ? MB_ENOERR : MB_ENORES;
 504:	84 e0       	ldi	r24, 0x04	; 4
 506:	19 c0       	rjmp	.+50     	; 0x53a <eMBRegisterCB+0x84>
    if( ( 0 < ucFunctionCode ) && ( ucFunctionCode <= 127 ) )
    {
        ENTER_CRITICAL_SECTION(  );
        if( pxHandler != NULL )
        {
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
 508:	e1 e6       	ldi	r30, 0x61	; 97
 50a:	f0 e0       	ldi	r31, 0x00	; 0
    eMBErrorCode    eStatus;

    if( ( 0 < ucFunctionCode ) && ( ucFunctionCode <= 127 ) )
    {
        ENTER_CRITICAL_SECTION(  );
        if( pxHandler != NULL )
 50c:	20 e0       	ldi	r18, 0x00	; 0
 50e:	30 e0       	ldi	r19, 0x00	; 0
        }
        else
        {
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
            {
                if( xFuncHandlers[i].ucFunctionCode == ucFunctionCode )
 510:	90 81       	ld	r25, Z
 512:	98 17       	cp	r25, r24
 514:	59 f4       	brne	.+22     	; 0x52c <eMBRegisterCB+0x76>
                {
                    xFuncHandlers[i].ucFunctionCode = 0;
 516:	f9 01       	movw	r30, r18
 518:	ee 0f       	add	r30, r30
 51a:	ff 1f       	adc	r31, r31
 51c:	e2 0f       	add	r30, r18
 51e:	f3 1f       	adc	r31, r19
 520:	ef 59       	subi	r30, 0x9F	; 159
 522:	ff 4f       	sbci	r31, 0xFF	; 255
 524:	10 82       	st	Z, r1
                    xFuncHandlers[i].pxHandler = NULL;
 526:	12 82       	std	Z+2, r1	; 0x02
 528:	11 82       	std	Z+1, r1	; 0x01
 52a:	06 c0       	rjmp	.+12     	; 0x538 <eMBRegisterCB+0x82>
            }
            eStatus = ( i != MB_FUNC_HANDLERS_MAX ) ? MB_ENOERR : MB_ENORES;
        }
        else
        {
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
 52c:	2f 5f       	subi	r18, 0xFF	; 255
 52e:	3f 4f       	sbci	r19, 0xFF	; 255
 530:	33 96       	adiw	r30, 0x03	; 3
 532:	20 31       	cpi	r18, 0x10	; 16
 534:	31 05       	cpc	r19, r1
 536:	61 f7       	brne	.-40     	; 0x510 <eMBRegisterCB+0x5a>
                    xFuncHandlers[i].pxHandler = NULL;
                    break;
                }
            }
            /* Remove can't fail. */
            eStatus = MB_ENOERR;
 538:	80 e0       	ldi	r24, 0x00	; 0
        }
        EXIT_CRITICAL_SECTION(  );
 53a:	78 94       	sei
 53c:	08 95       	ret
    }
    else
    {
        eStatus = MB_EINVAL;
 53e:	82 e0       	ldi	r24, 0x02	; 2
    }
    return eStatus;
}
 540:	08 95       	ret

00000542 <eMBClose>:
eMBErrorCode
eMBClose( void )
{
    eMBErrorCode    eStatus = MB_ENOERR;

    if( eMBState == STATE_DISABLED )
 542:	80 91 60 00 	lds	r24, 0x0060
 546:	81 30       	cpi	r24, 0x01	; 1
 548:	49 f4       	brne	.+18     	; 0x55c <eMBClose+0x1a>
    {
        if( pvMBFrameCloseCur != NULL )
 54a:	e0 91 30 01 	lds	r30, 0x0130
 54e:	f0 91 31 01 	lds	r31, 0x0131
 552:	30 97       	sbiw	r30, 0x00	; 0
 554:	29 f0       	breq	.+10     	; 0x560 <eMBClose+0x1e>
        {
            pvMBFrameCloseCur(  );
 556:	09 95       	icall


eMBErrorCode
eMBClose( void )
{
    eMBErrorCode    eStatus = MB_ENOERR;
 558:	80 e0       	ldi	r24, 0x00	; 0
 55a:	08 95       	ret
            pvMBFrameCloseCur(  );
        }
    }
    else
    {
        eStatus = MB_EILLSTATE;
 55c:	86 e0       	ldi	r24, 0x06	; 6
 55e:	08 95       	ret


eMBErrorCode
eMBClose( void )
{
    eMBErrorCode    eStatus = MB_ENOERR;
 560:	80 e0       	ldi	r24, 0x00	; 0
    else
    {
        eStatus = MB_EILLSTATE;
    }
    return eStatus;
}
 562:	08 95       	ret

00000564 <eMBEnable>:
eMBErrorCode
eMBEnable( void )
{
    eMBErrorCode    eStatus = MB_ENOERR;

    if( eMBState == STATE_DISABLED )
 564:	80 91 60 00 	lds	r24, 0x0060
 568:	81 30       	cpi	r24, 0x01	; 1
 56a:	49 f4       	brne	.+18     	; 0x57e <eMBEnable+0x1a>
    {
        /* Activate the protocol stack. */
        pvMBFrameStartCur(  );
 56c:	e0 91 2e 01 	lds	r30, 0x012E
 570:	f0 91 2f 01 	lds	r31, 0x012F
 574:	09 95       	icall
        eMBState = STATE_ENABLED;
 576:	10 92 60 00 	sts	0x0060, r1
}

eMBErrorCode
eMBEnable( void )
{
    eMBErrorCode    eStatus = MB_ENOERR;
 57a:	80 e0       	ldi	r24, 0x00	; 0
 57c:	08 95       	ret
        pvMBFrameStartCur(  );
        eMBState = STATE_ENABLED;
    }
    else
    {
        eStatus = MB_EILLSTATE;
 57e:	86 e0       	ldi	r24, 0x06	; 6
    }
    return eStatus;
}
 580:	08 95       	ret

00000582 <eMBDisable>:
eMBErrorCode
eMBDisable( void )
{
    eMBErrorCode    eStatus;

    if( eMBState == STATE_ENABLED )
 582:	80 91 60 00 	lds	r24, 0x0060
 586:	88 23       	and	r24, r24
 588:	49 f4       	brne	.+18     	; 0x59c <eMBDisable+0x1a>
    {
        pvMBFrameStopCur(  );
 58a:	e0 91 2c 01 	lds	r30, 0x012C
 58e:	f0 91 2d 01 	lds	r31, 0x012D
 592:	09 95       	icall
        eMBState = STATE_DISABLED;
 594:	81 e0       	ldi	r24, 0x01	; 1
 596:	80 93 60 00 	sts	0x0060, r24
 59a:	02 c0       	rjmp	.+4      	; 0x5a0 <eMBDisable+0x1e>
        eStatus = MB_ENOERR;
    }
    else if( eMBState == STATE_DISABLED )
 59c:	81 30       	cpi	r24, 0x01	; 1
 59e:	11 f4       	brne	.+4      	; 0x5a4 <eMBDisable+0x22>
    {
        eStatus = MB_ENOERR;
 5a0:	80 e0       	ldi	r24, 0x00	; 0
 5a2:	08 95       	ret
    }
    else
    {
        eStatus = MB_EILLSTATE;
 5a4:	86 e0       	ldi	r24, 0x06	; 6
    }
    return eStatus;
}
 5a6:	08 95       	ret

000005a8 <eMBPoll>:

eMBErrorCode
eMBPoll( void )
{
 5a8:	df 93       	push	r29
 5aa:	cf 93       	push	r28
 5ac:	0f 92       	push	r0
 5ae:	cd b7       	in	r28, 0x3d	; 61
 5b0:	de b7       	in	r29, 0x3e	; 62
    int             i;
    eMBErrorCode    eStatus = MB_ENOERR;
    eMBEventType    eEvent;

    /* Check if the protocol stack is ready. */
    if( eMBState != STATE_ENABLED )
 5b2:	80 91 60 00 	lds	r24, 0x0060
 5b6:	88 23       	and	r24, r24
 5b8:	09 f0       	breq	.+2      	; 0x5bc <eMBPoll+0x14>
 5ba:	7d c0       	rjmp	.+250    	; 0x6b6 <eMBPoll+0x10e>
        return MB_EILLSTATE;
    }

    /* Check if there is a event available. If not return control to caller.
     * Otherwise we will handle the event. */
    if( xMBPortEventGet( &eEvent ) == TRUE )
 5bc:	ce 01       	movw	r24, r28
 5be:	01 96       	adiw	r24, 0x01	; 1
 5c0:	0e 94 8e 06 	call	0xd1c	; 0xd1c <xMBPortEventGet>
 5c4:	81 30       	cpi	r24, 0x01	; 1
 5c6:	09 f0       	breq	.+2      	; 0x5ca <eMBPoll+0x22>
 5c8:	78 c0       	rjmp	.+240    	; 0x6ba <eMBPoll+0x112>
    {
        switch ( eEvent )
 5ca:	99 81       	ldd	r25, Y+1	; 0x01
 5cc:	91 30       	cpi	r25, 0x01	; 1
 5ce:	21 f0       	breq	.+8      	; 0x5d8 <eMBPoll+0x30>
 5d0:	92 30       	cpi	r25, 0x02	; 2
 5d2:	09 f0       	breq	.+2      	; 0x5d6 <eMBPoll+0x2e>
 5d4:	72 c0       	rjmp	.+228    	; 0x6ba <eMBPoll+0x112>
 5d6:	1b c0       	rjmp	.+54     	; 0x60e <eMBPoll+0x66>
        {
        case EV_READY:
            break;

        case EV_FRAME_RECEIVED:
            eStatus = peMBFrameReceiveCur( &ucRcvAddress, &ucMBFrame, &usLength );
 5d8:	e0 91 20 01 	lds	r30, 0x0120
 5dc:	f0 91 21 01 	lds	r31, 0x0121
 5e0:	89 e2       	ldi	r24, 0x29	; 41
 5e2:	91 e0       	ldi	r25, 0x01	; 1
 5e4:	6a e2       	ldi	r22, 0x2A	; 42
 5e6:	71 e0       	ldi	r23, 0x01	; 1
 5e8:	46 e2       	ldi	r20, 0x26	; 38
 5ea:	51 e0       	ldi	r21, 0x01	; 1
 5ec:	09 95       	icall
            if( eStatus == MB_ENOERR )
 5ee:	88 23       	and	r24, r24
 5f0:	09 f0       	breq	.+2      	; 0x5f4 <eMBPoll+0x4c>
 5f2:	63 c0       	rjmp	.+198    	; 0x6ba <eMBPoll+0x112>
            {
                /* Check if the frame is for us. If not ignore the frame. */
                if( ( ucRcvAddress == ucMBAddress ) || ( ucRcvAddress == MB_ADDRESS_BROADCAST ) )
 5f4:	80 91 29 01 	lds	r24, 0x0129
 5f8:	90 91 22 01 	lds	r25, 0x0122
 5fc:	89 17       	cp	r24, r25
 5fe:	19 f0       	breq	.+6      	; 0x606 <eMBPoll+0x5e>
 600:	88 23       	and	r24, r24
 602:	09 f0       	breq	.+2      	; 0x606 <eMBPoll+0x5e>
 604:	5a c0       	rjmp	.+180    	; 0x6ba <eMBPoll+0x112>
                {
                    ( void )xMBPortEventPost( EV_EXECUTE );
 606:	82 e0       	ldi	r24, 0x02	; 2
 608:	0e 94 87 06 	call	0xd0e	; 0xd0e <xMBPortEventPost>
 60c:	56 c0       	rjmp	.+172    	; 0x6ba <eMBPoll+0x112>
                }
            }
            break;

        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
 60e:	a0 91 2a 01 	lds	r26, 0x012A
 612:	b0 91 2b 01 	lds	r27, 0x012B
 616:	9c 91       	ld	r25, X
 618:	90 93 28 01 	sts	0x0128, r25
            eException = MB_EX_ILLEGAL_FUNCTION;
 61c:	80 93 25 01 	sts	0x0125, r24
 620:	e1 e6       	ldi	r30, 0x61	; 97
 622:	f0 e0       	ldi	r31, 0x00	; 0
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
 624:	20 e0       	ldi	r18, 0x00	; 0
 626:	30 e0       	ldi	r19, 0x00	; 0
            {
                /* No more function handlers registered. Abort. */
                if( xFuncHandlers[i].ucFunctionCode == 0 )
 628:	80 81       	ld	r24, Z
 62a:	88 23       	and	r24, r24
 62c:	c9 f0       	breq	.+50     	; 0x660 <eMBPoll+0xb8>
                {
                    break;
                }
                else if( xFuncHandlers[i].ucFunctionCode == ucFunctionCode )
 62e:	89 17       	cp	r24, r25
 630:	89 f4       	brne	.+34     	; 0x654 <eMBPoll+0xac>
                {
                    eException = xFuncHandlers[i].pxHandler( ucMBFrame, &usLength );
 632:	f9 01       	movw	r30, r18
 634:	ee 0f       	add	r30, r30
 636:	ff 1f       	adc	r31, r31
 638:	e2 0f       	add	r30, r18
 63a:	f3 1f       	adc	r31, r19
 63c:	ef 59       	subi	r30, 0x9F	; 159
 63e:	ff 4f       	sbci	r31, 0xFF	; 255
 640:	01 80       	ldd	r0, Z+1	; 0x01
 642:	f2 81       	ldd	r31, Z+2	; 0x02
 644:	e0 2d       	mov	r30, r0
 646:	cd 01       	movw	r24, r26
 648:	66 e2       	ldi	r22, 0x26	; 38
 64a:	71 e0       	ldi	r23, 0x01	; 1
 64c:	09 95       	icall
 64e:	80 93 25 01 	sts	0x0125, r24
                    break;
 652:	06 c0       	rjmp	.+12     	; 0x660 <eMBPoll+0xb8>
            break;

        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
            eException = MB_EX_ILLEGAL_FUNCTION;
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
 654:	2f 5f       	subi	r18, 0xFF	; 255
 656:	3f 4f       	sbci	r19, 0xFF	; 255
 658:	33 96       	adiw	r30, 0x03	; 3
 65a:	20 31       	cpi	r18, 0x10	; 16
 65c:	31 05       	cpc	r19, r1
 65e:	21 f7       	brne	.-56     	; 0x628 <eMBPoll+0x80>
                }
            }

            /* If the request was not sent to the broadcast address we
             * return a reply. */
            if( ucRcvAddress != MB_ADDRESS_BROADCAST )
 660:	80 91 29 01 	lds	r24, 0x0129
 664:	88 23       	and	r24, r24
 666:	49 f1       	breq	.+82     	; 0x6ba <eMBPoll+0x112>
            {
                if( eException != MB_EX_NONE )
 668:	90 91 25 01 	lds	r25, 0x0125
 66c:	99 23       	and	r25, r25
 66e:	99 f0       	breq	.+38     	; 0x696 <eMBPoll+0xee>
                {
                    /* An exception occured. Build an error frame. */
                    usLength = 0;
                    ucMBFrame[usLength++] = ( UCHAR )( ucFunctionCode | MB_FUNC_ERROR );
 670:	e0 91 2a 01 	lds	r30, 0x012A
 674:	f0 91 2b 01 	lds	r31, 0x012B
 678:	80 91 28 01 	lds	r24, 0x0128
 67c:	80 68       	ori	r24, 0x80	; 128
 67e:	80 83       	st	Z, r24
                    ucMBFrame[usLength++] = eException;
 680:	e0 91 2a 01 	lds	r30, 0x012A
 684:	f0 91 2b 01 	lds	r31, 0x012B
 688:	91 83       	std	Z+1, r25	; 0x01
 68a:	82 e0       	ldi	r24, 0x02	; 2
 68c:	90 e0       	ldi	r25, 0x00	; 0
 68e:	90 93 27 01 	sts	0x0127, r25
 692:	80 93 26 01 	sts	0x0126, r24
                }
                if( ( eMBCurrentMode == MB_ASCII ) && MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS )
                {
                    vMBPortTimersDelay( MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS );
                }                
                eStatus = peMBFrameSendCur( ucMBAddress, ucMBFrame, usLength );
 696:	60 91 2a 01 	lds	r22, 0x012A
 69a:	70 91 2b 01 	lds	r23, 0x012B
 69e:	40 91 26 01 	lds	r20, 0x0126
 6a2:	50 91 27 01 	lds	r21, 0x0127
 6a6:	e0 91 23 01 	lds	r30, 0x0123
 6aa:	f0 91 24 01 	lds	r31, 0x0124
 6ae:	80 91 22 01 	lds	r24, 0x0122
 6b2:	09 95       	icall
 6b4:	02 c0       	rjmp	.+4      	; 0x6ba <eMBPoll+0x112>
    eMBEventType    eEvent;

    /* Check if the protocol stack is ready. */
    if( eMBState != STATE_ENABLED )
    {
        return MB_EILLSTATE;
 6b6:	86 e0       	ldi	r24, 0x06	; 6
 6b8:	01 c0       	rjmp	.+2      	; 0x6bc <eMBPoll+0x114>

        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
 6ba:	80 e0       	ldi	r24, 0x00	; 0
}
 6bc:	0f 90       	pop	r0
 6be:	cf 91       	pop	r28
 6c0:	df 91       	pop	r29
 6c2:	08 95       	ret

000006c4 <usMBCRC16>:
    0x40
};

USHORT
usMBCRC16( UCHAR * pucFrame, USHORT usLen )
{
 6c4:	dc 01       	movw	r26, r24
    UCHAR           ucCRCHi = 0xFF;
    UCHAR           ucCRCLo = 0xFF;
 6c6:	4f ef       	ldi	r20, 0xFF	; 255
};

USHORT
usMBCRC16( UCHAR * pucFrame, USHORT usLen )
{
    UCHAR           ucCRCHi = 0xFF;
 6c8:	5f ef       	ldi	r21, 0xFF	; 255
    UCHAR           ucCRCLo = 0xFF;
    int             iIndex;

    while( usLen-- )
 6ca:	0f c0       	rjmp	.+30     	; 0x6ea <usMBCRC16+0x26>
    {
        iIndex = ucCRCLo ^ *( pucFrame++ );
 6cc:	2d 91       	ld	r18, X+
        ucCRCLo = ucCRCHi ^ pgm_read_byte( &aucCRCHi[iIndex] );
 6ce:	84 2f       	mov	r24, r20
 6d0:	82 27       	eor	r24, r18
 6d2:	90 e0       	ldi	r25, 0x00	; 0
 6d4:	fc 01       	movw	r30, r24
 6d6:	ec 5a       	subi	r30, 0xAC	; 172
 6d8:	ff 4f       	sbci	r31, 0xFF	; 255
 6da:	44 91       	lpm	r20, Z+
 6dc:	45 27       	eor	r20, r21
        ucCRCHi = pgm_read_byte( &aucCRCLo[iIndex] );;
 6de:	8c 5a       	subi	r24, 0xAC	; 172
 6e0:	9e 4f       	sbci	r25, 0xFE	; 254
 6e2:	fc 01       	movw	r30, r24
 6e4:	54 91       	lpm	r21, Z+
 6e6:	61 50       	subi	r22, 0x01	; 1
 6e8:	70 40       	sbci	r23, 0x00	; 0
{
    UCHAR           ucCRCHi = 0xFF;
    UCHAR           ucCRCLo = 0xFF;
    int             iIndex;

    while( usLen-- )
 6ea:	61 15       	cp	r22, r1
 6ec:	71 05       	cpc	r23, r1
 6ee:	71 f7       	brne	.-36     	; 0x6cc <usMBCRC16+0x8>
    {
        iIndex = ucCRCLo ^ *( pucFrame++ );
        ucCRCLo = ucCRCHi ^ pgm_read_byte( &aucCRCHi[iIndex] );
        ucCRCHi = pgm_read_byte( &aucCRCLo[iIndex] );;
    }
    return ucCRCHi << 8 | ucCRCLo;
 6f0:	35 2f       	mov	r19, r21
 6f2:	20 e0       	ldi	r18, 0x00	; 0
 6f4:	e4 2f       	mov	r30, r20
 6f6:	f0 e0       	ldi	r31, 0x00	; 0
 6f8:	e2 2b       	or	r30, r18
 6fa:	f3 2b       	or	r31, r19
}
 6fc:	cf 01       	movw	r24, r30
 6fe:	08 95       	ret

00000700 <eMBFuncWriteHoldingRegister>:
{
    USHORT          usRegAddress;
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
 700:	fb 01       	movw	r30, r22
 702:	20 81       	ld	r18, Z
 704:	31 81       	ldd	r19, Z+1	; 0x01
 706:	25 30       	cpi	r18, 0x05	; 5
 708:	31 05       	cpc	r19, r1
 70a:	a1 f4       	brne	.+40     	; 0x734 <eMBFuncWriteHoldingRegister+0x34>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
 70c:	fc 01       	movw	r30, r24
 70e:	31 81       	ldd	r19, Z+1	; 0x01
 710:	20 e0       	ldi	r18, 0x00	; 0
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
 712:	62 81       	ldd	r22, Z+2	; 0x02
 714:	70 e0       	ldi	r23, 0x00	; 0
 716:	62 2b       	or	r22, r18
 718:	73 2b       	or	r23, r19
        usRegAddress++;
 71a:	6f 5f       	subi	r22, 0xFF	; 255
 71c:	7f 4f       	sbci	r23, 0xFF	; 255

        /* Make callback to update the value. */
        eRegStatus = eMBRegHoldingCB( &pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF],
 71e:	03 96       	adiw	r24, 0x03	; 3
 720:	41 e0       	ldi	r20, 0x01	; 1
 722:	50 e0       	ldi	r21, 0x00	; 0
 724:	21 e0       	ldi	r18, 0x01	; 1
 726:	0e 94 cc 01 	call	0x398	; 0x398 <eMBRegHoldingCB>
                                      usRegAddress, 1, MB_REG_WRITE );

        /* If an error occured convert it into a Modbus exception. */
        if( eRegStatus != MB_ENOERR )
 72a:	88 23       	and	r24, r24
 72c:	29 f0       	breq	.+10     	; 0x738 <eMBFuncWriteHoldingRegister+0x38>
        {
            eStatus = prveMBError2Exception( eRegStatus );
 72e:	0e 94 79 06 	call	0xcf2	; 0xcf2 <prveMBError2Exception>
 732:	08 95       	ret
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 734:	83 e0       	ldi	r24, 0x03	; 3
 736:	08 95       	ret

eMBException
eMBFuncWriteHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
    USHORT          usRegAddress;
    eMBException    eStatus = MB_EX_NONE;
 738:	80 e0       	ldi	r24, 0x00	; 0
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 73a:	08 95       	ret

0000073c <eMBFuncWriteMultipleHoldingRegister>:
#endif

#if MB_FUNC_WRITE_MULTIPLE_HOLDING_ENABLED > 0
eMBException
eMBFuncWriteMultipleHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
 73c:	cf 93       	push	r28
 73e:	df 93       	push	r29
 740:	fc 01       	movw	r30, r24
 742:	eb 01       	movw	r28, r22
    UCHAR           ucRegByteCount;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_WRITE_MUL_SIZE_MIN + MB_PDU_SIZE_MIN ) )
 744:	88 81       	ld	r24, Y
 746:	99 81       	ldd	r25, Y+1	; 0x01
 748:	86 30       	cpi	r24, 0x06	; 6
 74a:	91 05       	cpc	r25, r1
 74c:	48 f1       	brcs	.+82     	; 0x7a0 <eMBFuncWriteMultipleHoldingRegister+0x64>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
 74e:	21 81       	ldd	r18, Z+1	; 0x01
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
 750:	62 81       	ldd	r22, Z+2	; 0x02
        usRegAddress++;

        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_REGCNT_OFF] << 8 );
 752:	93 81       	ldd	r25, Z+3	; 0x03
 754:	80 e0       	ldi	r24, 0x00	; 0
        usRegCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_REGCNT_OFF + 1] );
 756:	44 81       	ldd	r20, Z+4	; 0x04
 758:	50 e0       	ldi	r21, 0x00	; 0
 75a:	48 2b       	or	r20, r24
 75c:	59 2b       	or	r21, r25

        ucRegByteCount = pucFrame[MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF];
 75e:	35 81       	ldd	r19, Z+5	; 0x05

        if( ( usRegCount >= 1 ) &&
 760:	ca 01       	movw	r24, r20
 762:	01 97       	sbiw	r24, 0x01	; 1
 764:	88 37       	cpi	r24, 0x78	; 120
 766:	91 05       	cpc	r25, r1
 768:	d8 f4       	brcc	.+54     	; 0x7a0 <eMBFuncWriteMultipleHoldingRegister+0x64>
            ( usRegCount <= MB_PDU_FUNC_WRITE_MUL_REGCNT_MAX ) &&
            ( ucRegByteCount == ( UCHAR ) ( 2 * usRegCount ) ) )
 76a:	84 2f       	mov	r24, r20
 76c:	88 0f       	add	r24, r24
        usRegCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_REGCNT_OFF + 1] );

        ucRegByteCount = pucFrame[MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF];

        if( ( usRegCount >= 1 ) &&
            ( usRegCount <= MB_PDU_FUNC_WRITE_MUL_REGCNT_MAX ) &&
 76e:	38 17       	cp	r19, r24
 770:	b9 f4       	brne	.+46     	; 0x7a0 <eMBFuncWriteMultipleHoldingRegister+0x64>
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_WRITE_MUL_SIZE_MIN + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
 772:	92 2f       	mov	r25, r18
 774:	80 e0       	ldi	r24, 0x00	; 0
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
 776:	70 e0       	ldi	r23, 0x00	; 0
 778:	68 2b       	or	r22, r24
 77a:	79 2b       	or	r23, r25
        usRegAddress++;
 77c:	6f 5f       	subi	r22, 0xFF	; 255
 77e:	7f 4f       	sbci	r23, 0xFF	; 255
        if( ( usRegCount >= 1 ) &&
            ( usRegCount <= MB_PDU_FUNC_WRITE_MUL_REGCNT_MAX ) &&
            ( ucRegByteCount == ( UCHAR ) ( 2 * usRegCount ) ) )
        {
            /* Make callback to update the register values. */
            eRegStatus =
 780:	cf 01       	movw	r24, r30
 782:	06 96       	adiw	r24, 0x06	; 6
 784:	21 e0       	ldi	r18, 0x01	; 1
 786:	0e 94 cc 01 	call	0x398	; 0x398 <eMBRegHoldingCB>
                eMBRegHoldingCB( &pucFrame[MB_PDU_FUNC_WRITE_MUL_VALUES_OFF],
                                 usRegAddress, usRegCount, MB_REG_WRITE );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 78a:	88 23       	and	r24, r24
 78c:	19 f0       	breq	.+6      	; 0x794 <eMBFuncWriteMultipleHoldingRegister+0x58>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 78e:	0e 94 79 06 	call	0xcf2	; 0xcf2 <prveMBError2Exception>
 792:	07 c0       	rjmp	.+14     	; 0x7a2 <eMBFuncWriteMultipleHoldingRegister+0x66>
            {
                /* The response contains the function code, the starting
                 * address and the quantity of registers. We reuse the
                 * old values in the buffer because they are still valid.
                 */
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
 794:	85 e0       	ldi	r24, 0x05	; 5
 796:	90 e0       	ldi	r25, 0x00	; 0
 798:	99 83       	std	Y+1, r25	; 0x01
 79a:	88 83       	st	Y, r24
{
    USHORT          usRegAddress;
    USHORT          usRegCount;
    UCHAR           ucRegByteCount;

    eMBException    eStatus = MB_EX_NONE;
 79c:	80 e0       	ldi	r24, 0x00	; 0
 79e:	01 c0       	rjmp	.+2      	; 0x7a2 <eMBFuncWriteMultipleHoldingRegister+0x66>
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 7a0:	83 e0       	ldi	r24, 0x03	; 3
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 7a2:	df 91       	pop	r29
 7a4:	cf 91       	pop	r28
 7a6:	08 95       	ret

000007a8 <eMBFuncReadHoldingRegister>:

#if MB_FUNC_READ_HOLDING_ENABLED > 0

eMBException
eMBFuncReadHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
 7a8:	0f 93       	push	r16
 7aa:	1f 93       	push	r17
 7ac:	cf 93       	push	r28
 7ae:	df 93       	push	r29
 7b0:	fc 01       	movw	r30, r24
 7b2:	eb 01       	movw	r28, r22
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
 7b4:	88 81       	ld	r24, Y
 7b6:	99 81       	ldd	r25, Y+1	; 0x01
 7b8:	85 30       	cpi	r24, 0x05	; 5
 7ba:	91 05       	cpc	r25, r1
 7bc:	c9 f5       	brne	.+114    	; 0x830 <eMBFuncReadHoldingRegister+0x88>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
 7be:	cf 01       	movw	r24, r30
 7c0:	01 96       	adiw	r24, 0x01	; 1
 7c2:	51 81       	ldd	r21, Z+1	; 0x01
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
 7c4:	62 81       	ldd	r22, Z+2	; 0x02
        usRegAddress++;

        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF] << 8 );
        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF + 1] );
 7c6:	44 81       	ldd	r20, Z+4	; 0x04
 7c8:	04 2f       	mov	r16, r20
 7ca:	10 e0       	ldi	r17, 0x00	; 0

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usRegCount >= 1 ) && ( usRegCount <= MB_PDU_FUNC_READ_REGCNT_MAX ) )
 7cc:	98 01       	movw	r18, r16
 7ce:	21 50       	subi	r18, 0x01	; 1
 7d0:	30 40       	sbci	r19, 0x00	; 0
 7d2:	2d 37       	cpi	r18, 0x7D	; 125
 7d4:	31 05       	cpc	r19, r1
 7d6:	60 f5       	brcc	.+88     	; 0x830 <eMBFuncReadHoldingRegister+0x88>
        {
            /* Set the current PDU data pointer to the beginning. */
            pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
            *usLen = MB_PDU_FUNC_OFF;
 7d8:	19 82       	std	Y+1, r1	; 0x01
 7da:	18 82       	st	Y, r1

            /* First byte contains the function code. */
            *pucFrameCur++ = MB_FUNC_READ_HOLDING_REGISTER;
 7dc:	23 e0       	ldi	r18, 0x03	; 3
 7de:	20 83       	st	Z, r18
            *usLen += 1;
 7e0:	28 81       	ld	r18, Y
 7e2:	39 81       	ldd	r19, Y+1	; 0x01
 7e4:	2f 5f       	subi	r18, 0xFF	; 255
 7e6:	3f 4f       	sbci	r19, 0xFF	; 255
 7e8:	39 83       	std	Y+1, r19	; 0x01
 7ea:	28 83       	st	Y, r18

            /* Second byte in the response contain the number of bytes. */
            *pucFrameCur++ = ( UCHAR ) ( usRegCount * 2 );
 7ec:	44 0f       	add	r20, r20
 7ee:	41 83       	std	Z+1, r20	; 0x01
            *usLen += 1;
 7f0:	28 81       	ld	r18, Y
 7f2:	39 81       	ldd	r19, Y+1	; 0x01
 7f4:	2f 5f       	subi	r18, 0xFF	; 255
 7f6:	3f 4f       	sbci	r19, 0xFF	; 255
 7f8:	39 83       	std	Y+1, r19	; 0x01
 7fa:	28 83       	st	Y, r18
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
 7fc:	35 2f       	mov	r19, r21
 7fe:	20 e0       	ldi	r18, 0x00	; 0
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
 800:	70 e0       	ldi	r23, 0x00	; 0
 802:	62 2b       	or	r22, r18
 804:	73 2b       	or	r23, r19
        usRegAddress++;
 806:	6f 5f       	subi	r22, 0xFF	; 255
 808:	7f 4f       	sbci	r23, 0xFF	; 255
            /* Second byte in the response contain the number of bytes. */
            *pucFrameCur++ = ( UCHAR ) ( usRegCount * 2 );
            *usLen += 1;

            /* Make callback to fill the buffer. */
            eRegStatus = eMBRegHoldingCB( pucFrameCur, usRegAddress, usRegCount, MB_REG_READ );
 80a:	01 96       	adiw	r24, 0x01	; 1
 80c:	a8 01       	movw	r20, r16
 80e:	0e 94 cc 01 	call	0x398	; 0x398 <eMBRegHoldingCB>
            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 812:	88 23       	and	r24, r24
 814:	19 f0       	breq	.+6      	; 0x81c <eMBFuncReadHoldingRegister+0x74>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 816:	0e 94 79 06 	call	0xcf2	; 0xcf2 <prveMBError2Exception>
 81a:	0b c0       	rjmp	.+22     	; 0x832 <eMBFuncReadHoldingRegister+0x8a>
            }
            else
            {
                *usLen += usRegCount * 2;
 81c:	00 0f       	add	r16, r16
 81e:	11 1f       	adc	r17, r17
 820:	88 81       	ld	r24, Y
 822:	99 81       	ldd	r25, Y+1	; 0x01
 824:	80 0f       	add	r24, r16
 826:	91 1f       	adc	r25, r17
 828:	99 83       	std	Y+1, r25	; 0x01
 82a:	88 83       	st	Y, r24
{
    USHORT          usRegAddress;
    USHORT          usRegCount;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
 82c:	80 e0       	ldi	r24, 0x00	; 0
 82e:	01 c0       	rjmp	.+2      	; 0x832 <eMBFuncReadHoldingRegister+0x8a>
                *usLen += usRegCount * 2;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 830:	83 e0       	ldi	r24, 0x03	; 3
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 832:	df 91       	pop	r29
 834:	cf 91       	pop	r28
 836:	1f 91       	pop	r17
 838:	0f 91       	pop	r16
 83a:	08 95       	ret

0000083c <eMBFuncReadWriteMultipleHoldingRegister>:

#if MB_FUNC_READWRITE_HOLDING_ENABLED > 0

eMBException
eMBFuncReadWriteMultipleHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
 83c:	af 92       	push	r10
 83e:	bf 92       	push	r11
 840:	cf 92       	push	r12
 842:	df 92       	push	r13
 844:	ef 92       	push	r14
 846:	ff 92       	push	r15
 848:	0f 93       	push	r16
 84a:	1f 93       	push	r17
 84c:	cf 93       	push	r28
 84e:	df 93       	push	r29
 850:	ec 01       	movw	r28, r24
 852:	8b 01       	movw	r16, r22
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_READWRITE_SIZE_MIN + MB_PDU_SIZE_MIN ) )
 854:	fb 01       	movw	r30, r22
 856:	80 81       	ld	r24, Z
 858:	91 81       	ldd	r25, Z+1	; 0x01
 85a:	8a 30       	cpi	r24, 0x0A	; 10
 85c:	91 05       	cpc	r25, r1
 85e:	08 f4       	brcc	.+2      	; 0x862 <eMBFuncReadWriteMultipleHoldingRegister+0x26>
 860:	6a c0       	rjmp	.+212    	; 0x936 <eMBFuncReadWriteMultipleHoldingRegister+0xfa>
    {
        usRegReadAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF] << 8U );
 862:	6e 01       	movw	r12, r28
 864:	08 94       	sec
 866:	c1 1c       	adc	r12, r1
 868:	d1 1c       	adc	r13, r1
 86a:	b9 80       	ldd	r11, Y+1	; 0x01
        usRegReadAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF + 1] );
 86c:	aa 80       	ldd	r10, Y+2	; 0x02
        usRegReadAddress++;

        usRegReadCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_REGCNT_OFF] << 8U );
 86e:	9b 81       	ldd	r25, Y+3	; 0x03
 870:	80 e0       	ldi	r24, 0x00	; 0
        usRegReadCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_REGCNT_OFF + 1] );
 872:	ec 80       	ldd	r14, Y+4	; 0x04
 874:	ff 24       	eor	r15, r15
 876:	e8 2a       	or	r14, r24
 878:	f9 2a       	or	r15, r25

        usRegWriteAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF] << 8U );
 87a:	7d 81       	ldd	r23, Y+5	; 0x05
        usRegWriteAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF + 1] );
 87c:	6e 81       	ldd	r22, Y+6	; 0x06
        usRegWriteAddress++;

        usRegWriteCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF] << 8U );
 87e:	9f 81       	ldd	r25, Y+7	; 0x07
        usRegWriteCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF + 1] );
 880:	48 85       	ldd	r20, Y+8	; 0x08

        ucRegWriteByteCount = pucFrame[MB_PDU_FUNC_READWRITE_BYTECNT_OFF];
 882:	89 85       	ldd	r24, Y+9	; 0x09

        if( ( usRegReadCount >= 1 ) && ( usRegReadCount <= 0x7D ) &&
 884:	97 01       	movw	r18, r14
 886:	21 50       	subi	r18, 0x01	; 1
 888:	30 40       	sbci	r19, 0x00	; 0
 88a:	2d 37       	cpi	r18, 0x7D	; 125
 88c:	31 05       	cpc	r19, r1
 88e:	08 f0       	brcs	.+2      	; 0x892 <eMBFuncReadWriteMultipleHoldingRegister+0x56>
 890:	54 c0       	rjmp	.+168    	; 0x93a <eMBFuncReadWriteMultipleHoldingRegister+0xfe>

        usRegWriteAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF] << 8U );
        usRegWriteAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF + 1] );
        usRegWriteAddress++;

        usRegWriteCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF] << 8U );
 892:	39 2f       	mov	r19, r25
 894:	20 e0       	ldi	r18, 0x00	; 0
        usRegWriteCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF + 1] );
 896:	50 e0       	ldi	r21, 0x00	; 0
 898:	42 2b       	or	r20, r18
 89a:	53 2b       	or	r21, r19

        ucRegWriteByteCount = pucFrame[MB_PDU_FUNC_READWRITE_BYTECNT_OFF];

        if( ( usRegReadCount >= 1 ) && ( usRegReadCount <= 0x7D ) &&
 89c:	41 15       	cp	r20, r1
 89e:	51 05       	cpc	r21, r1
 8a0:	09 f4       	brne	.+2      	; 0x8a4 <eMBFuncReadWriteMultipleHoldingRegister+0x68>
 8a2:	4b c0       	rjmp	.+150    	; 0x93a <eMBFuncReadWriteMultipleHoldingRegister+0xfe>
            ( usRegWriteCount >= 1 ) && ( usRegWriteCount <= 0x79 ) &&
 8a4:	4a 37       	cpi	r20, 0x7A	; 122
 8a6:	51 05       	cpc	r21, r1
 8a8:	08 f0       	brcs	.+2      	; 0x8ac <eMBFuncReadWriteMultipleHoldingRegister+0x70>
 8aa:	47 c0       	rjmp	.+142    	; 0x93a <eMBFuncReadWriteMultipleHoldingRegister+0xfe>
            ( ( 2 * usRegWriteCount ) == ucRegWriteByteCount ) )
 8ac:	9a 01       	movw	r18, r20
 8ae:	22 0f       	add	r18, r18
 8b0:	33 1f       	adc	r19, r19
 8b2:	90 e0       	ldi	r25, 0x00	; 0
        usRegWriteCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF + 1] );

        ucRegWriteByteCount = pucFrame[MB_PDU_FUNC_READWRITE_BYTECNT_OFF];

        if( ( usRegReadCount >= 1 ) && ( usRegReadCount <= 0x7D ) &&
            ( usRegWriteCount >= 1 ) && ( usRegWriteCount <= 0x79 ) &&
 8b4:	28 17       	cp	r18, r24
 8b6:	39 07       	cpc	r19, r25
 8b8:	09 f0       	breq	.+2      	; 0x8bc <eMBFuncReadWriteMultipleHoldingRegister+0x80>
 8ba:	3f c0       	rjmp	.+126    	; 0x93a <eMBFuncReadWriteMultipleHoldingRegister+0xfe>
        usRegReadAddress++;

        usRegReadCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_REGCNT_OFF] << 8U );
        usRegReadCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_REGCNT_OFF + 1] );

        usRegWriteAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF] << 8U );
 8bc:	97 2f       	mov	r25, r23
 8be:	80 e0       	ldi	r24, 0x00	; 0
        usRegWriteAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF + 1] );
 8c0:	70 e0       	ldi	r23, 0x00	; 0
 8c2:	68 2b       	or	r22, r24
 8c4:	79 2b       	or	r23, r25
        usRegWriteAddress++;
 8c6:	6f 5f       	subi	r22, 0xFF	; 255
 8c8:	7f 4f       	sbci	r23, 0xFF	; 255
        if( ( usRegReadCount >= 1 ) && ( usRegReadCount <= 0x7D ) &&
            ( usRegWriteCount >= 1 ) && ( usRegWriteCount <= 0x79 ) &&
            ( ( 2 * usRegWriteCount ) == ucRegWriteByteCount ) )
        {
            /* Make callback to update the register values. */
            eRegStatus = eMBRegHoldingCB( &pucFrame[MB_PDU_FUNC_READWRITE_WRITE_VALUES_OFF],
 8ca:	ce 01       	movw	r24, r28
 8cc:	0a 96       	adiw	r24, 0x0a	; 10
 8ce:	21 e0       	ldi	r18, 0x01	; 1
 8d0:	0e 94 cc 01 	call	0x398	; 0x398 <eMBRegHoldingCB>
                                          usRegWriteAddress, usRegWriteCount, MB_REG_WRITE );

            if( eRegStatus == MB_ENOERR )
 8d4:	88 23       	and	r24, r24
 8d6:	61 f5       	brne	.+88     	; 0x930 <eMBFuncReadWriteMultipleHoldingRegister+0xf4>
            {
                /* Set the current PDU data pointer to the beginning. */
                pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
                *usLen = MB_PDU_FUNC_OFF;
 8d8:	f8 01       	movw	r30, r16
 8da:	11 82       	std	Z+1, r1	; 0x01
 8dc:	10 82       	st	Z, r1

                /* First byte contains the function code. */
                *pucFrameCur++ = MB_FUNC_READWRITE_MULTIPLE_REGISTERS;
 8de:	87 e1       	ldi	r24, 0x17	; 23
 8e0:	88 83       	st	Y, r24
                *usLen += 1;
 8e2:	80 81       	ld	r24, Z
 8e4:	91 81       	ldd	r25, Z+1	; 0x01
 8e6:	01 96       	adiw	r24, 0x01	; 1
 8e8:	91 83       	std	Z+1, r25	; 0x01
 8ea:	80 83       	st	Z, r24

                /* Second byte in the response contain the number of bytes. */
                *pucFrameCur++ = ( UCHAR ) ( usRegReadCount * 2 );
 8ec:	8e 2d       	mov	r24, r14
 8ee:	88 0f       	add	r24, r24
 8f0:	89 83       	std	Y+1, r24	; 0x01
                *usLen += 1;
 8f2:	80 81       	ld	r24, Z
 8f4:	91 81       	ldd	r25, Z+1	; 0x01
 8f6:	01 96       	adiw	r24, 0x01	; 1
 8f8:	91 83       	std	Z+1, r25	; 0x01
 8fa:	80 83       	st	Z, r24
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_READWRITE_SIZE_MIN + MB_PDU_SIZE_MIN ) )
    {
        usRegReadAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF] << 8U );
 8fc:	9b 2d       	mov	r25, r11
 8fe:	80 e0       	ldi	r24, 0x00	; 0
        usRegReadAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF + 1] );
 900:	6a 2d       	mov	r22, r10
 902:	70 e0       	ldi	r23, 0x00	; 0
 904:	68 2b       	or	r22, r24
 906:	79 2b       	or	r23, r25
        usRegReadAddress++;
 908:	6f 5f       	subi	r22, 0xFF	; 255
 90a:	7f 4f       	sbci	r23, 0xFF	; 255
                /* Second byte in the response contain the number of bytes. */
                *pucFrameCur++ = ( UCHAR ) ( usRegReadCount * 2 );
                *usLen += 1;

                /* Make the read callback. */
                eRegStatus =
 90c:	c6 01       	movw	r24, r12
 90e:	01 96       	adiw	r24, 0x01	; 1
 910:	a7 01       	movw	r20, r14
 912:	20 e0       	ldi	r18, 0x00	; 0
 914:	0e 94 cc 01 	call	0x398	; 0x398 <eMBRegHoldingCB>
                    eMBRegHoldingCB( pucFrameCur, usRegReadAddress, usRegReadCount, MB_REG_READ );
                if( eRegStatus == MB_ENOERR )
 918:	88 23       	and	r24, r24
 91a:	51 f4       	brne	.+20     	; 0x930 <eMBFuncReadWriteMultipleHoldingRegister+0xf4>
                {
                    *usLen += 2 * usRegReadCount;
 91c:	ee 0c       	add	r14, r14
 91e:	ff 1c       	adc	r15, r15
 920:	f8 01       	movw	r30, r16
 922:	80 81       	ld	r24, Z
 924:	91 81       	ldd	r25, Z+1	; 0x01
 926:	8e 0d       	add	r24, r14
 928:	9f 1d       	adc	r25, r15
 92a:	91 83       	std	Z+1, r25	; 0x01
 92c:	80 83       	st	Z, r24
 92e:	03 c0       	rjmp	.+6      	; 0x936 <eMBFuncReadWriteMultipleHoldingRegister+0xfa>
                }
            }
            if( eRegStatus != MB_ENOERR )
            {
                eStatus = prveMBError2Exception( eRegStatus );
 930:	0e 94 79 06 	call	0xcf2	; 0xcf2 <prveMBError2Exception>
 934:	03 c0       	rjmp	.+6      	; 0x93c <eMBFuncReadWriteMultipleHoldingRegister+0x100>
    USHORT          usRegWriteAddress;
    USHORT          usRegWriteCount;
    UCHAR           ucRegWriteByteCount;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
 936:	80 e0       	ldi	r24, 0x00	; 0
 938:	01 c0       	rjmp	.+2      	; 0x93c <eMBFuncReadWriteMultipleHoldingRegister+0x100>
                eStatus = prveMBError2Exception( eRegStatus );
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 93a:	83 e0       	ldi	r24, 0x03	; 3
        }
    }
    return eStatus;
}
 93c:	df 91       	pop	r29
 93e:	cf 91       	pop	r28
 940:	1f 91       	pop	r17
 942:	0f 91       	pop	r16
 944:	ff 90       	pop	r15
 946:	ef 90       	pop	r14
 948:	df 90       	pop	r13
 94a:	cf 90       	pop	r12
 94c:	bf 90       	pop	r11
 94e:	af 90       	pop	r10
 950:	08 95       	ret

00000952 <eMBRTUInit>:
static volatile USHORT usRcvBufferPos;

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBRTUInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
 952:	cf 92       	push	r12
 954:	df 92       	push	r13
 956:	ef 92       	push	r14
 958:	ff 92       	push	r15
 95a:	0f 93       	push	r16
 95c:	86 2f       	mov	r24, r22
 95e:	69 01       	movw	r12, r18
 960:	7a 01       	movw	r14, r20
    eMBErrorCode    eStatus = MB_ENOERR;
    ULONG           usTimerT35_50us;

    ( void )ucSlaveAddress;
    ENTER_CRITICAL_SECTION(  );
 962:	f8 94       	cli

    /* Modbus RTU uses 8 Databits. */
    if( xMBPortSerialInit( ucPort, ulBaudRate, 8, eParity ) != TRUE )
 964:	ba 01       	movw	r22, r20
 966:	a9 01       	movw	r20, r18
 968:	28 e0       	ldi	r18, 0x08	; 8
 96a:	0e 94 b0 06 	call	0xd60	; 0xd60 <xMBPortSerialInit>
 96e:	81 30       	cpi	r24, 0x01	; 1
 970:	09 f5       	brne	.+66     	; 0x9b4 <eMBRTUInit+0x62>
    else
    {
        /* If baudrate > 19200 then we should use the fixed timer values
         * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
         */
        if( ulBaudRate > 19200 )
 972:	81 e0       	ldi	r24, 0x01	; 1
 974:	c8 16       	cp	r12, r24
 976:	8b e4       	ldi	r24, 0x4B	; 75
 978:	d8 06       	cpc	r13, r24
 97a:	80 e0       	ldi	r24, 0x00	; 0
 97c:	e8 06       	cpc	r14, r24
 97e:	80 e0       	ldi	r24, 0x00	; 0
 980:	f8 06       	cpc	r15, r24
 982:	68 f4       	brcc	.+26     	; 0x99e <eMBRTUInit+0x4c>
             *             = 11 * Ticks_per_1s / Baudrate
             *             = 220000 / Baudrate
             * The reload for t3.5 is 1.5 times this value and similary
             * for t3.5.
             */
            usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
 984:	a7 01       	movw	r20, r14
 986:	96 01       	movw	r18, r12
 988:	22 0f       	add	r18, r18
 98a:	33 1f       	adc	r19, r19
 98c:	44 1f       	adc	r20, r20
 98e:	55 1f       	adc	r21, r21
 990:	60 ea       	ldi	r22, 0xA0	; 160
 992:	7f e7       	ldi	r23, 0x7F	; 127
 994:	87 e1       	ldi	r24, 0x17	; 23
 996:	90 e0       	ldi	r25, 0x00	; 0
 998:	0e 94 c6 07 	call	0xf8c	; 0xf8c <__udivmodsi4>
 99c:	04 c0       	rjmp	.+8      	; 0x9a6 <eMBRTUInit+0x54>
        /* If baudrate > 19200 then we should use the fixed timer values
         * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
         */
        if( ulBaudRate > 19200 )
        {
            usTimerT35_50us = 35;       /* 1800us. */
 99e:	23 e2       	ldi	r18, 0x23	; 35
 9a0:	30 e0       	ldi	r19, 0x00	; 0
 9a2:	40 e0       	ldi	r20, 0x00	; 0
 9a4:	50 e0       	ldi	r21, 0x00	; 0
             * The reload for t3.5 is 1.5 times this value and similary
             * for t3.5.
             */
            usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
        }
        if( xMBPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
 9a6:	c9 01       	movw	r24, r18
 9a8:	0e 94 66 07 	call	0xecc	; 0xecc <xMBPortTimersInit>
 9ac:	81 30       	cpi	r24, 0x01	; 1
 9ae:	11 f4       	brne	.+4      	; 0x9b4 <eMBRTUInit+0x62>

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBRTUInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
    eMBErrorCode    eStatus = MB_ENOERR;
 9b0:	80 e0       	ldi	r24, 0x00	; 0
 9b2:	01 c0       	rjmp	.+2      	; 0x9b6 <eMBRTUInit+0x64>
             */
            usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
        }
        if( xMBPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
        {
            eStatus = MB_EPORTERR;
 9b4:	83 e0       	ldi	r24, 0x03	; 3
        }
    }
    EXIT_CRITICAL_SECTION(  );
 9b6:	78 94       	sei

    return eStatus;
}
 9b8:	0f 91       	pop	r16
 9ba:	ff 90       	pop	r15
 9bc:	ef 90       	pop	r14
 9be:	df 90       	pop	r13
 9c0:	cf 90       	pop	r12
 9c2:	08 95       	ret

000009c4 <eMBRTUStart>:

void
eMBRTUStart( void )
{
    ENTER_CRITICAL_SECTION(  );
 9c4:	f8 94       	cli
    /* Initially the receiver is in the state STATE_RX_INIT. we start
     * the timer and if no character is received within t3.5 we change
     * to STATE_RX_IDLE. This makes sure that we delay startup of the
     * modbus protocol stack until the bus is free.
     */
    eRcvState = STATE_RX_INIT;
 9c6:	10 92 33 01 	sts	0x0133, r1
    vMBPortSerialEnable( TRUE, FALSE );
 9ca:	81 e0       	ldi	r24, 0x01	; 1
 9cc:	60 e0       	ldi	r22, 0x00	; 0
 9ce:	0e 94 9c 06 	call	0xd38	; 0xd38 <vMBPortSerialEnable>
    vMBPortTimersEnable(  );
 9d2:	0e 94 4b 07 	call	0xe96	; 0xe96 <vMBPortTimersEnable>

    EXIT_CRITICAL_SECTION(  );
 9d6:	78 94       	sei
}
 9d8:	08 95       	ret

000009da <eMBRTUStop>:

void
eMBRTUStop( void )
{
    ENTER_CRITICAL_SECTION(  );
 9da:	f8 94       	cli
    vMBPortSerialEnable( FALSE, FALSE );
 9dc:	80 e0       	ldi	r24, 0x00	; 0
 9de:	60 e0       	ldi	r22, 0x00	; 0
 9e0:	0e 94 9c 06 	call	0xd38	; 0xd38 <vMBPortSerialEnable>
    vMBPortTimersDisable(  );
 9e4:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vMBPortTimersDisable>
    EXIT_CRITICAL_SECTION(  );
 9e8:	78 94       	sei
}
 9ea:	08 95       	ret

000009ec <eMBRTUReceive>:

eMBErrorCode
eMBRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
{
 9ec:	ef 92       	push	r14
 9ee:	ff 92       	push	r15
 9f0:	0f 93       	push	r16
 9f2:	1f 93       	push	r17
 9f4:	cf 93       	push	r28
 9f6:	df 93       	push	r29
 9f8:	8c 01       	movw	r16, r24
 9fa:	7b 01       	movw	r14, r22
 9fc:	ea 01       	movw	r28, r20
    BOOL            xFrameReceived = FALSE;
    eMBErrorCode    eStatus = MB_ENOERR;

    ENTER_CRITICAL_SECTION(  );
 9fe:	f8 94       	cli
    assert( usRcvBufferPos < MB_SER_PDU_SIZE_MAX );

    /* Length and CRC check */
    if( ( usRcvBufferPos >= MB_SER_PDU_SIZE_MIN )
 a00:	80 91 39 01 	lds	r24, 0x0139
 a04:	90 91 3a 01 	lds	r25, 0x013A
 a08:	84 30       	cpi	r24, 0x04	; 4
 a0a:	91 05       	cpc	r25, r1
 a0c:	e0 f0       	brcs	.+56     	; 0xa46 <eMBRTUReceive+0x5a>
        && ( usMBCRC16( ( UCHAR * ) ucRTUBuf, usRcvBufferPos ) == 0 ) )
 a0e:	60 91 39 01 	lds	r22, 0x0139
 a12:	70 91 3a 01 	lds	r23, 0x013A
 a16:	89 e4       	ldi	r24, 0x49	; 73
 a18:	91 e0       	ldi	r25, 0x01	; 1
 a1a:	0e 94 62 03 	call	0x6c4	; 0x6c4 <usMBCRC16>
 a1e:	00 97       	sbiw	r24, 0x00	; 0
 a20:	91 f4       	brne	.+36     	; 0xa46 <eMBRTUReceive+0x5a>
    {
        /* Save the address field. All frames are passed to the upper layed
         * and the decision if a frame is used is done there.
         */
        *pucRcvAddress = ucRTUBuf[MB_SER_PDU_ADDR_OFF];
 a22:	80 91 49 01 	lds	r24, 0x0149
 a26:	f8 01       	movw	r30, r16
 a28:	80 83       	st	Z, r24

        /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus
         * size of address field and CRC checksum.
         */
        *pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC );
 a2a:	80 91 39 01 	lds	r24, 0x0139
 a2e:	90 91 3a 01 	lds	r25, 0x013A
 a32:	03 97       	sbiw	r24, 0x03	; 3
 a34:	99 83       	std	Y+1, r25	; 0x01
 a36:	88 83       	st	Y, r24

        /* Return the start of the Modbus PDU to the caller. */
        *pucFrame = ( UCHAR * ) & ucRTUBuf[MB_SER_PDU_PDU_OFF];
 a38:	8a e4       	ldi	r24, 0x4A	; 74
 a3a:	91 e0       	ldi	r25, 0x01	; 1
 a3c:	f7 01       	movw	r30, r14
 a3e:	91 83       	std	Z+1, r25	; 0x01
 a40:	80 83       	st	Z, r24

eMBErrorCode
eMBRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
{
    BOOL            xFrameReceived = FALSE;
    eMBErrorCode    eStatus = MB_ENOERR;
 a42:	80 e0       	ldi	r24, 0x00	; 0
         */
        *pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC );

        /* Return the start of the Modbus PDU to the caller. */
        *pucFrame = ( UCHAR * ) & ucRTUBuf[MB_SER_PDU_PDU_OFF];
        xFrameReceived = TRUE;
 a44:	01 c0       	rjmp	.+2      	; 0xa48 <eMBRTUReceive+0x5c>
    }
    else
    {
        eStatus = MB_EIO;
 a46:	85 e0       	ldi	r24, 0x05	; 5
    }

    EXIT_CRITICAL_SECTION(  );
 a48:	78 94       	sei
    return eStatus;
}
 a4a:	df 91       	pop	r29
 a4c:	cf 91       	pop	r28
 a4e:	1f 91       	pop	r17
 a50:	0f 91       	pop	r16
 a52:	ff 90       	pop	r15
 a54:	ef 90       	pop	r14
 a56:	08 95       	ret

00000a58 <eMBRTUSend>:

eMBErrorCode
eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
 a58:	1f 93       	push	r17
    eMBErrorCode    eStatus = MB_ENOERR;
    USHORT          usCRC16;

    ENTER_CRITICAL_SECTION(  );
 a5a:	f8 94       	cli

    /* Check if the receiver is still in idle state. If not we where to
     * slow with processing the received frame and the master sent another
     * frame on the network. We have to abort sending the frame.
     */
    if( eRcvState == STATE_RX_IDLE )
 a5c:	10 91 33 01 	lds	r17, 0x0133
 a60:	11 30       	cpi	r17, 0x01	; 1
 a62:	09 f0       	breq	.+2      	; 0xa66 <eMBRTUSend+0xe>
 a64:	42 c0       	rjmp	.+132    	; 0xaea <eMBRTUSend+0x92>
    {
        /* First byte before the Modbus-PDU is the slave address. */
        pucSndBufferCur = ( UCHAR * ) pucFrame - 1;
 a66:	fb 01       	movw	r30, r22
 a68:	31 97       	sbiw	r30, 0x01	; 1
 a6a:	f0 93 38 01 	sts	0x0138, r31
 a6e:	e0 93 37 01 	sts	0x0137, r30
        usSndBufferCount = 1;
 a72:	21 e0       	ldi	r18, 0x01	; 1
 a74:	30 e0       	ldi	r19, 0x00	; 0
 a76:	30 93 36 01 	sts	0x0136, r19
 a7a:	20 93 35 01 	sts	0x0135, r18

        /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
        pucSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
 a7e:	80 83       	st	Z, r24
        usSndBufferCount += usLength;
 a80:	80 91 35 01 	lds	r24, 0x0135
 a84:	90 91 36 01 	lds	r25, 0x0136
 a88:	84 0f       	add	r24, r20
 a8a:	95 1f       	adc	r25, r21
 a8c:	90 93 36 01 	sts	0x0136, r25
 a90:	80 93 35 01 	sts	0x0135, r24

        /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
        usCRC16 = usMBCRC16( ( UCHAR * ) pucSndBufferCur, usSndBufferCount );
 a94:	60 91 35 01 	lds	r22, 0x0135
 a98:	70 91 36 01 	lds	r23, 0x0136
 a9c:	cf 01       	movw	r24, r30
 a9e:	0e 94 62 03 	call	0x6c4	; 0x6c4 <usMBCRC16>
 aa2:	49 2f       	mov	r20, r25
        ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
 aa4:	20 91 35 01 	lds	r18, 0x0135
 aa8:	30 91 36 01 	lds	r19, 0x0136
 aac:	f9 01       	movw	r30, r18
 aae:	e7 5b       	subi	r30, 0xB7	; 183
 ab0:	fe 4f       	sbci	r31, 0xFE	; 254
 ab2:	80 83       	st	Z, r24
 ab4:	2f 5f       	subi	r18, 0xFF	; 255
 ab6:	3f 4f       	sbci	r19, 0xFF	; 255
 ab8:	30 93 36 01 	sts	0x0136, r19
 abc:	20 93 35 01 	sts	0x0135, r18
        ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 >> 8 );
 ac0:	80 91 35 01 	lds	r24, 0x0135
 ac4:	90 91 36 01 	lds	r25, 0x0136
 ac8:	fc 01       	movw	r30, r24
 aca:	e7 5b       	subi	r30, 0xB7	; 183
 acc:	fe 4f       	sbci	r31, 0xFE	; 254
 ace:	40 83       	st	Z, r20
 ad0:	01 96       	adiw	r24, 0x01	; 1
 ad2:	90 93 36 01 	sts	0x0136, r25
 ad6:	80 93 35 01 	sts	0x0135, r24

        /* Activate the transmitter. */
        eSndState = STATE_TX_XMIT;
 ada:	10 93 34 01 	sts	0x0134, r17
        vMBPortSerialEnable( FALSE, TRUE );
 ade:	80 e0       	ldi	r24, 0x00	; 0
 ae0:	61 e0       	ldi	r22, 0x01	; 1
 ae2:	0e 94 9c 06 	call	0xd38	; 0xd38 <vMBPortSerialEnable>
}

eMBErrorCode
eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
    eMBErrorCode    eStatus = MB_ENOERR;
 ae6:	80 e0       	ldi	r24, 0x00	; 0
 ae8:	01 c0       	rjmp	.+2      	; 0xaec <eMBRTUSend+0x94>
        eSndState = STATE_TX_XMIT;
        vMBPortSerialEnable( FALSE, TRUE );
    }
    else
    {
        eStatus = MB_EIO;
 aea:	85 e0       	ldi	r24, 0x05	; 5
    }
    EXIT_CRITICAL_SECTION(  );
 aec:	78 94       	sei
    return eStatus;
}
 aee:	1f 91       	pop	r17
 af0:	08 95       	ret

00000af2 <xMBRTUReceiveFSM>:

BOOL
xMBRTUReceiveFSM( void )
{
 af2:	df 93       	push	r29
 af4:	cf 93       	push	r28
 af6:	0f 92       	push	r0
 af8:	cd b7       	in	r28, 0x3d	; 61
 afa:	de b7       	in	r29, 0x3e	; 62
    UCHAR           ucByte;

    assert( eSndState == STATE_TX_IDLE );

    /* Always read the character. */
    ( void )xMBPortSerialGetByte( ( CHAR * ) & ucByte );
 afc:	ce 01       	movw	r24, r28
 afe:	01 96       	adiw	r24, 0x01	; 1
 b00:	0e 94 ed 06 	call	0xdda	; 0xdda <xMBPortSerialGetByte>

    switch ( eRcvState )
 b04:	80 91 33 01 	lds	r24, 0x0133
 b08:	81 30       	cpi	r24, 0x01	; 1
 b0a:	39 f0       	breq	.+14     	; 0xb1a <xMBRTUReceiveFSM+0x28>
 b0c:	81 30       	cpi	r24, 0x01	; 1
 b0e:	98 f1       	brcs	.+102    	; 0xb76 <xMBRTUReceiveFSM+0x84>
 b10:	82 30       	cpi	r24, 0x02	; 2
 b12:	b9 f0       	breq	.+46     	; 0xb42 <xMBRTUReceiveFSM+0x50>
 b14:	83 30       	cpi	r24, 0x03	; 3
 b16:	89 f5       	brne	.+98     	; 0xb7a <xMBRTUReceiveFSM+0x88>
 b18:	2e c0       	rjmp	.+92     	; 0xb76 <xMBRTUReceiveFSM+0x84>
        /* In the idle state we wait for a new character. If a character
         * is received the t1.5 and t3.5 timers are started and the
         * receiver is in the state STATE_RX_RECEIVCE.
         */
    case STATE_RX_IDLE:
        usRcvBufferPos = 0;
 b1a:	10 92 3a 01 	sts	0x013A, r1
 b1e:	10 92 39 01 	sts	0x0139, r1
        ucRTUBuf[usRcvBufferPos++] = ucByte;
 b22:	80 91 39 01 	lds	r24, 0x0139
 b26:	90 91 3a 01 	lds	r25, 0x013A
 b2a:	29 81       	ldd	r18, Y+1	; 0x01
 b2c:	fc 01       	movw	r30, r24
 b2e:	e7 5b       	subi	r30, 0xB7	; 183
 b30:	fe 4f       	sbci	r31, 0xFE	; 254
 b32:	20 83       	st	Z, r18
 b34:	01 96       	adiw	r24, 0x01	; 1
 b36:	90 93 3a 01 	sts	0x013A, r25
 b3a:	80 93 39 01 	sts	0x0139, r24
        eRcvState = STATE_RX_RCV;
 b3e:	82 e0       	ldi	r24, 0x02	; 2
 b40:	18 c0       	rjmp	.+48     	; 0xb72 <xMBRTUReceiveFSM+0x80>
         * every character received. If more than the maximum possible
         * number of bytes in a modbus frame is received the frame is
         * ignored.
         */
    case STATE_RX_RCV:
        if( usRcvBufferPos < MB_SER_PDU_SIZE_MAX )
 b42:	80 91 39 01 	lds	r24, 0x0139
 b46:	90 91 3a 01 	lds	r25, 0x013A
 b4a:	8f 3f       	cpi	r24, 0xFF	; 255
 b4c:	91 05       	cpc	r25, r1
 b4e:	09 f0       	breq	.+2      	; 0xb52 <xMBRTUReceiveFSM+0x60>
 b50:	78 f4       	brcc	.+30     	; 0xb70 <xMBRTUReceiveFSM+0x7e>
        {
            ucRTUBuf[usRcvBufferPos++] = ucByte;
 b52:	80 91 39 01 	lds	r24, 0x0139
 b56:	90 91 3a 01 	lds	r25, 0x013A
 b5a:	29 81       	ldd	r18, Y+1	; 0x01
 b5c:	fc 01       	movw	r30, r24
 b5e:	e7 5b       	subi	r30, 0xB7	; 183
 b60:	fe 4f       	sbci	r31, 0xFE	; 254
 b62:	20 83       	st	Z, r18
 b64:	01 96       	adiw	r24, 0x01	; 1
 b66:	90 93 3a 01 	sts	0x013A, r25
 b6a:	80 93 39 01 	sts	0x0139, r24
 b6e:	03 c0       	rjmp	.+6      	; 0xb76 <xMBRTUReceiveFSM+0x84>
        }
        else
        {
            eRcvState = STATE_RX_ERROR;
 b70:	83 e0       	ldi	r24, 0x03	; 3
 b72:	80 93 33 01 	sts	0x0133, r24
        }
        vMBPortTimersEnable(  );
 b76:	0e 94 4b 07 	call	0xe96	; 0xe96 <vMBPortTimersEnable>
        break;
    }
    return xTaskNeedSwitch;
}
 b7a:	80 e0       	ldi	r24, 0x00	; 0
 b7c:	0f 90       	pop	r0
 b7e:	cf 91       	pop	r28
 b80:	df 91       	pop	r29
 b82:	08 95       	ret

00000b84 <xMBRTUTransmitFSM>:

BOOL
xMBRTUTransmitFSM( void )
{
 b84:	1f 93       	push	r17
    BOOL            xNeedPoll = FALSE;

    assert( eRcvState == STATE_RX_IDLE );

    switch ( eSndState )
 b86:	80 91 34 01 	lds	r24, 0x0134
 b8a:	88 23       	and	r24, r24
 b8c:	19 f0       	breq	.+6      	; 0xb94 <xMBRTUTransmitFSM+0x10>
 b8e:	81 30       	cpi	r24, 0x01	; 1
 b90:	89 f5       	brne	.+98     	; 0xbf4 <xMBRTUTransmitFSM+0x70>
 b92:	05 c0       	rjmp	.+10     	; 0xb9e <xMBRTUTransmitFSM+0x1a>
    {
        /* We should not get a transmitter event if the transmitter is in
         * idle state.  */
    case STATE_TX_IDLE:
        /* enable receiver/disable transmitter. */
        vMBPortSerialEnable( TRUE, FALSE );
 b94:	81 e0       	ldi	r24, 0x01	; 1
 b96:	60 e0       	ldi	r22, 0x00	; 0
 b98:	0e 94 9c 06 	call	0xd38	; 0xd38 <vMBPortSerialEnable>
 b9c:	2b c0       	rjmp	.+86     	; 0xbf4 <xMBRTUTransmitFSM+0x70>
        break;

    case STATE_TX_XMIT:
        /* check if we are finished. */
        if( usSndBufferCount != 0 )
 b9e:	80 91 35 01 	lds	r24, 0x0135
 ba2:	90 91 36 01 	lds	r25, 0x0136
 ba6:	00 97       	sbiw	r24, 0x00	; 0
 ba8:	d1 f0       	breq	.+52     	; 0xbde <xMBRTUTransmitFSM+0x5a>
        {
            xMBPortSerialPutByte( ( CHAR )*pucSndBufferCur );
 baa:	e0 91 37 01 	lds	r30, 0x0137
 bae:	f0 91 38 01 	lds	r31, 0x0138
 bb2:	80 81       	ld	r24, Z
 bb4:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <xMBPortSerialPutByte>
            pucSndBufferCur++;  /* next byte in sendbuffer. */
 bb8:	80 91 37 01 	lds	r24, 0x0137
 bbc:	90 91 38 01 	lds	r25, 0x0138
 bc0:	01 96       	adiw	r24, 0x01	; 1
 bc2:	90 93 38 01 	sts	0x0138, r25
 bc6:	80 93 37 01 	sts	0x0137, r24
            usSndBufferCount--;
 bca:	80 91 35 01 	lds	r24, 0x0135
 bce:	90 91 36 01 	lds	r25, 0x0136
 bd2:	01 97       	sbiw	r24, 0x01	; 1
 bd4:	90 93 36 01 	sts	0x0136, r25
 bd8:	80 93 35 01 	sts	0x0135, r24
 bdc:	0b c0       	rjmp	.+22     	; 0xbf4 <xMBRTUTransmitFSM+0x70>
        }
        else
        {
            xNeedPoll = xMBPortEventPost( EV_FRAME_SENT );
 bde:	83 e0       	ldi	r24, 0x03	; 3
 be0:	0e 94 87 06 	call	0xd0e	; 0xd0e <xMBPortEventPost>
 be4:	18 2f       	mov	r17, r24
            /* Disable transmitter. This prevents another transmit buffer
             * empty interrupt. */
            vMBPortSerialEnable( TRUE, FALSE );
 be6:	81 e0       	ldi	r24, 0x01	; 1
 be8:	60 e0       	ldi	r22, 0x00	; 0
 bea:	0e 94 9c 06 	call	0xd38	; 0xd38 <vMBPortSerialEnable>
            eSndState = STATE_TX_IDLE;
 bee:	10 92 34 01 	sts	0x0134, r1
 bf2:	01 c0       	rjmp	.+2      	; 0xbf6 <xMBRTUTransmitFSM+0x72>
}

BOOL
xMBRTUTransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
 bf4:	10 e0       	ldi	r17, 0x00	; 0
        }
        break;
    }

    return xNeedPoll;
}
 bf6:	81 2f       	mov	r24, r17
 bf8:	1f 91       	pop	r17
 bfa:	08 95       	ret

00000bfc <xMBRTUTimerT35Expired>:

BOOL
xMBRTUTimerT35Expired( void )
{
 bfc:	df 93       	push	r29
 bfe:	cf 93       	push	r28
 c00:	0f 92       	push	r0
 c02:	cd b7       	in	r28, 0x3d	; 61
 c04:	de b7       	in	r29, 0x3e	; 62
    BOOL            xNeedPoll = FALSE;

    switch ( eRcvState )
 c06:	80 91 33 01 	lds	r24, 0x0133
 c0a:	88 23       	and	r24, r24
 c0c:	19 f0       	breq	.+6      	; 0xc14 <xMBRTUTimerT35Expired+0x18>
 c0e:	82 30       	cpi	r24, 0x02	; 2
 c10:	39 f4       	brne	.+14     	; 0xc20 <xMBRTUTimerT35Expired+0x24>
 c12:	02 c0       	rjmp	.+4      	; 0xc18 <xMBRTUTimerT35Expired+0x1c>
    {
        /* Timer t35 expired. Startup phase is finished. */
    case STATE_RX_INIT:
        xNeedPoll = xMBPortEventPost( EV_READY );
 c14:	80 e0       	ldi	r24, 0x00	; 0
 c16:	01 c0       	rjmp	.+2      	; 0xc1a <xMBRTUTimerT35Expired+0x1e>
        break;

        /* A frame was received and t35 expired. Notify the listener that
         * a new frame was received. */
    case STATE_RX_RCV:
        xNeedPoll = xMBPortEventPost( EV_FRAME_RECEIVED );
 c18:	81 e0       	ldi	r24, 0x01	; 1
 c1a:	0e 94 87 06 	call	0xd0e	; 0xd0e <xMBPortEventPost>
        break;
 c1e:	01 c0       	rjmp	.+2      	; 0xc22 <xMBRTUTimerT35Expired+0x26>
}

BOOL
xMBRTUTimerT35Expired( void )
{
    BOOL            xNeedPoll = FALSE;
 c20:	80 e0       	ldi	r24, 0x00	; 0
    default:
        assert( ( eRcvState == STATE_RX_INIT ) ||
                ( eRcvState == STATE_RX_RCV ) || ( eRcvState == STATE_RX_ERROR ) );
    }

    vMBPortTimersDisable(  );
 c22:	89 83       	std	Y+1, r24	; 0x01
 c24:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vMBPortTimersDisable>
    eRcvState = STATE_RX_IDLE;
 c28:	91 e0       	ldi	r25, 0x01	; 1
 c2a:	90 93 33 01 	sts	0x0133, r25

    return xNeedPoll;
}
 c2e:	89 81       	ldd	r24, Y+1	; 0x01
 c30:	0f 90       	pop	r0
 c32:	cf 91       	pop	r28
 c34:	df 91       	pop	r29
 c36:	08 95       	ret

00000c38 <xMBUtilSetBits>:

/* ----------------------- Start implementation -----------------------------*/
void
xMBUtilSetBits( UCHAR * ucByteBuf, USHORT usBitOffset, UCHAR ucNBits,
                UCHAR ucValue )
{
 c38:	cf 93       	push	r28
 c3a:	df 93       	push	r29
    USHORT          usWordBuf;
    USHORT          usMask;
    USHORT          usByteOffset;
    USHORT          usNPreBits;
    USHORT          usValue = ucValue;
 c3c:	30 e0       	ldi	r19, 0x00	; 0
    /* Calculate byte offset for first byte containing the bit values starting
     * at usBitOffset. */
    usByteOffset = ( USHORT )( ( usBitOffset ) / BITS_UCHAR );

    /* How many bits precede our bits to set. */
    usNPreBits = ( USHORT )( usBitOffset - usByteOffset * BITS_UCHAR );
 c3e:	eb 01       	movw	r28, r22
 c40:	53 e0       	ldi	r21, 0x03	; 3
 c42:	d6 95       	lsr	r29
 c44:	c7 95       	ror	r28
 c46:	5a 95       	dec	r21
 c48:	e1 f7       	brne	.-8      	; 0xc42 <xMBUtilSetBits+0xa>
 c4a:	67 70       	andi	r22, 0x07	; 7
 c4c:	70 70       	andi	r23, 0x00	; 0

    /* Move bit field into position over bits to set */
    usValue <<= usNPreBits;

    /* Prepare a mask for setting the new bits. */
    usMask = ( USHORT )( ( 1 << ( USHORT ) ucNBits ) - 1 );
 c4e:	e1 e0       	ldi	r30, 0x01	; 1
 c50:	f0 e0       	ldi	r31, 0x00	; 0
 c52:	02 c0       	rjmp	.+4      	; 0xc58 <xMBUtilSetBits+0x20>
 c54:	ee 0f       	add	r30, r30
 c56:	ff 1f       	adc	r31, r31
 c58:	4a 95       	dec	r20
 c5a:	e2 f7       	brpl	.-8      	; 0xc54 <xMBUtilSetBits+0x1c>
 c5c:	31 97       	sbiw	r30, 0x01	; 1
    usMask <<= usBitOffset - usByteOffset * BITS_UCHAR;

    /* copy bits into temporary storage. */
    usWordBuf = ucByteBuf[usByteOffset];
 c5e:	dc 01       	movw	r26, r24
 c60:	ac 0f       	add	r26, r28
 c62:	bd 1f       	adc	r27, r29
 c64:	4c 91       	ld	r20, X
 c66:	50 e0       	ldi	r21, 0x00	; 0
    usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;
 c68:	21 96       	adiw	r28, 0x01	; 1
 c6a:	c8 0f       	add	r28, r24
 c6c:	d9 1f       	adc	r29, r25
 c6e:	98 81       	ld	r25, Y
 c70:	80 e0       	ldi	r24, 0x00	; 0
 c72:	48 2b       	or	r20, r24
 c74:	59 2b       	or	r21, r25
    /* Move bit field into position over bits to set */
    usValue <<= usNPreBits;

    /* Prepare a mask for setting the new bits. */
    usMask = ( USHORT )( ( 1 << ( USHORT ) ucNBits ) - 1 );
    usMask <<= usBitOffset - usByteOffset * BITS_UCHAR;
 c76:	06 2e       	mov	r0, r22
 c78:	02 c0       	rjmp	.+4      	; 0xc7e <xMBUtilSetBits+0x46>
 c7a:	ee 0f       	add	r30, r30
 c7c:	ff 1f       	adc	r31, r31
 c7e:	0a 94       	dec	r0
 c80:	e2 f7       	brpl	.-8      	; 0xc7a <xMBUtilSetBits+0x42>
    /* copy bits into temporary storage. */
    usWordBuf = ucByteBuf[usByteOffset];
    usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;

    /* Zero out bit field bits and then or value bits into them. */
    usWordBuf = ( USHORT )( ( usWordBuf & ( ~usMask ) ) | usValue );
 c82:	e0 95       	com	r30
 c84:	f0 95       	com	r31
 c86:	4e 23       	and	r20, r30
 c88:	5f 23       	and	r21, r31

    /* How many bits precede our bits to set. */
    usNPreBits = ( USHORT )( usBitOffset - usByteOffset * BITS_UCHAR );

    /* Move bit field into position over bits to set */
    usValue <<= usNPreBits;
 c8a:	02 c0       	rjmp	.+4      	; 0xc90 <xMBUtilSetBits+0x58>
 c8c:	22 0f       	add	r18, r18
 c8e:	33 1f       	adc	r19, r19
 c90:	6a 95       	dec	r22
 c92:	e2 f7       	brpl	.-8      	; 0xc8c <xMBUtilSetBits+0x54>
    /* copy bits into temporary storage. */
    usWordBuf = ucByteBuf[usByteOffset];
    usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;

    /* Zero out bit field bits and then or value bits into them. */
    usWordBuf = ( USHORT )( ( usWordBuf & ( ~usMask ) ) | usValue );
 c94:	42 2b       	or	r20, r18
 c96:	53 2b       	or	r21, r19

    /* move bits back into storage */
    ucByteBuf[usByteOffset] = ( UCHAR )( usWordBuf & 0xFF );
 c98:	4c 93       	st	X, r20
    ucByteBuf[usByteOffset + 1] = ( UCHAR )( usWordBuf >> BITS_UCHAR );
 c9a:	58 83       	st	Y, r21
}
 c9c:	df 91       	pop	r29
 c9e:	cf 91       	pop	r28
 ca0:	08 95       	ret

00000ca2 <xMBUtilGetBits>:
    USHORT          usByteOffset;
    USHORT          usNPreBits;

    /* Calculate byte offset for first byte containing the bit values starting
     * at usBitOffset. */
    usByteOffset = ( USHORT )( ( usBitOffset ) / BITS_UCHAR );
 ca2:	9b 01       	movw	r18, r22
 ca4:	f3 e0       	ldi	r31, 0x03	; 3
 ca6:	36 95       	lsr	r19
 ca8:	27 95       	ror	r18
 caa:	fa 95       	dec	r31
 cac:	e1 f7       	brne	.-8      	; 0xca6 <xMBUtilGetBits+0x4>

    /* Prepare a mask for setting the new bits. */
    usMask = ( USHORT )( ( 1 << ( USHORT ) ucNBits ) - 1 );

    /* copy bits into temporary storage. */
    usWordBuf = ucByteBuf[usByteOffset];
 cae:	dc 01       	movw	r26, r24
 cb0:	a2 0f       	add	r26, r18
 cb2:	b3 1f       	adc	r27, r19
 cb4:	8c 91       	ld	r24, X
 cb6:	90 e0       	ldi	r25, 0x00	; 0
    usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;
 cb8:	11 96       	adiw	r26, 0x01	; 1
 cba:	fc 91       	ld	r31, X
 cbc:	11 97       	sbiw	r26, 0x01	; 1
 cbe:	e0 e0       	ldi	r30, 0x00	; 0
 cc0:	8e 2b       	or	r24, r30
 cc2:	9f 2b       	or	r25, r31
    /* Calculate byte offset for first byte containing the bit values starting
     * at usBitOffset. */
    usByteOffset = ( USHORT )( ( usBitOffset ) / BITS_UCHAR );

    /* How many bits precede our bits to set. */
    usNPreBits = ( USHORT )( usBitOffset - usByteOffset * BITS_UCHAR );
 cc4:	e3 e0       	ldi	r30, 0x03	; 3
 cc6:	22 0f       	add	r18, r18
 cc8:	33 1f       	adc	r19, r19
 cca:	ea 95       	dec	r30
 ccc:	e1 f7       	brne	.-8      	; 0xcc6 <xMBUtilGetBits+0x24>
 cce:	62 1b       	sub	r22, r18
 cd0:	73 0b       	sbc	r23, r19
    /* copy bits into temporary storage. */
    usWordBuf = ucByteBuf[usByteOffset];
    usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;

    /* throw away unneeded bits. */
    usWordBuf >>= usNPreBits;
 cd2:	02 c0       	rjmp	.+4      	; 0xcd8 <xMBUtilGetBits+0x36>
 cd4:	96 95       	lsr	r25
 cd6:	87 95       	ror	r24
 cd8:	6a 95       	dec	r22
 cda:	e2 f7       	brpl	.-8      	; 0xcd4 <xMBUtilGetBits+0x32>

    /* How many bits precede our bits to set. */
    usNPreBits = ( USHORT )( usBitOffset - usByteOffset * BITS_UCHAR );

    /* Prepare a mask for setting the new bits. */
    usMask = ( USHORT )( ( 1 << ( USHORT ) ucNBits ) - 1 );
 cdc:	21 e0       	ldi	r18, 0x01	; 1
 cde:	30 e0       	ldi	r19, 0x00	; 0
 ce0:	02 c0       	rjmp	.+4      	; 0xce6 <xMBUtilGetBits+0x44>
 ce2:	22 0f       	add	r18, r18
 ce4:	33 1f       	adc	r19, r19
 ce6:	4a 95       	dec	r20
 ce8:	e2 f7       	brpl	.-8      	; 0xce2 <xMBUtilGetBits+0x40>
 cea:	21 50       	subi	r18, 0x01	; 1
 cec:	30 40       	sbci	r19, 0x00	; 0

    /* mask away bits above the requested bitfield. */
    usWordBuf &= usMask;

    return ( UCHAR ) usWordBuf;
}
 cee:	82 23       	and	r24, r18
 cf0:	08 95       	ret

00000cf2 <prveMBError2Exception>:

eMBException
prveMBError2Exception( eMBErrorCode eErrorCode )
{
 cf2:	88 30       	cpi	r24, 0x08	; 8
 cf4:	30 f4       	brcc	.+12     	; 0xd02 <prveMBError2Exception+0x10>
 cf6:	e8 2f       	mov	r30, r24
 cf8:	f0 e0       	ldi	r31, 0x00	; 0
 cfa:	ef 56       	subi	r30, 0x6F	; 111
 cfc:	ff 4f       	sbci	r31, 0xFF	; 255
 cfe:	80 81       	ld	r24, Z
 d00:	08 95       	ret
 d02:	84 e0       	ldi	r24, 0x04	; 4
            eStatus = MB_EX_SLAVE_DEVICE_FAILURE;
            break;
    }

    return eStatus;
}
 d04:	08 95       	ret

00000d06 <xMBPortEventInit>:

/* ----------------------- Start implementation -----------------------------*/
BOOL
xMBPortEventInit( void )
{
    xEventInQueue = FALSE;
 d06:	10 92 3b 01 	sts	0x013B, r1
    return TRUE;
}
 d0a:	81 e0       	ldi	r24, 0x01	; 1
 d0c:	08 95       	ret

00000d0e <xMBPortEventPost>:

BOOL
xMBPortEventPost( eMBEventType eEvent )
{
    xEventInQueue = TRUE;
 d0e:	91 e0       	ldi	r25, 0x01	; 1
 d10:	90 93 3b 01 	sts	0x013B, r25
    eQueuedEvent = eEvent;
 d14:	80 93 3c 01 	sts	0x013C, r24
    return TRUE;
}
 d18:	81 e0       	ldi	r24, 0x01	; 1
 d1a:	08 95       	ret

00000d1c <xMBPortEventGet>:
BOOL
xMBPortEventGet( eMBEventType * eEvent )
{
    BOOL            xEventHappened = FALSE;

    if( xEventInQueue )
 d1c:	20 91 3b 01 	lds	r18, 0x013B
 d20:	22 23       	and	r18, r18
 d22:	41 f0       	breq	.+16     	; 0xd34 <xMBPortEventGet+0x18>
    {
        *eEvent = eQueuedEvent;
 d24:	20 91 3c 01 	lds	r18, 0x013C
 d28:	fc 01       	movw	r30, r24
 d2a:	20 83       	st	Z, r18
        xEventInQueue = FALSE;
 d2c:	10 92 3b 01 	sts	0x013B, r1
        xEventHappened = TRUE;
 d30:	81 e0       	ldi	r24, 0x01	; 1
 d32:	08 95       	ret
}

BOOL
xMBPortEventGet( eMBEventType * eEvent )
{
    BOOL            xEventHappened = FALSE;
 d34:	80 e0       	ldi	r24, 0x00	; 0
        *eEvent = eQueuedEvent;
        xEventInQueue = FALSE;
        xEventHappened = TRUE;
    }
    return xEventHappened;
}
 d36:	08 95       	ret

00000d38 <vMBPortSerialEnable>:

void
vMBPortSerialEnable( BOOL xRxEnable, BOOL xTxEnable )
{
#ifdef RTS_ENABLE
    UCSRB |= _BV( TXEN ) | _BV(TXCIE);
 d38:	9a b1       	in	r25, 0x0a	; 10
 d3a:	98 64       	ori	r25, 0x48	; 72
 d3c:	9a b9       	out	0x0a, r25	; 10
#else
    UCSRB |= _BV( TXEN );
#endif

    if( xRxEnable )
 d3e:	88 23       	and	r24, r24
 d40:	19 f0       	breq	.+6      	; 0xd48 <vMBPortSerialEnable+0x10>
    {
        UCSRB |= _BV( RXEN ) | _BV( RXCIE );
 d42:	8a b1       	in	r24, 0x0a	; 10
 d44:	80 69       	ori	r24, 0x90	; 144
 d46:	02 c0       	rjmp	.+4      	; 0xd4c <vMBPortSerialEnable+0x14>
    }
    else
    {
        UCSRB &= ~( _BV( RXEN ) | _BV( RXCIE ) );
 d48:	8a b1       	in	r24, 0x0a	; 10
 d4a:	8f 76       	andi	r24, 0x6F	; 111
 d4c:	8a b9       	out	0x0a, r24	; 10
    }

    if( xTxEnable )
 d4e:	66 23       	and	r22, r22
 d50:	29 f0       	breq	.+10     	; 0xd5c <vMBPortSerialEnable+0x24>
    {
        UCSRB |= _BV( TXEN ) | _BV( UDRE );
 d52:	8a b1       	in	r24, 0x0a	; 10
 d54:	88 62       	ori	r24, 0x28	; 40
 d56:	8a b9       	out	0x0a, r24	; 10
#ifdef RTS_ENABLE
        RTS_HIGH;
 d58:	92 9a       	sbi	0x12, 2	; 18
 d5a:	08 95       	ret
#endif
    }
    else
    {
        UCSRB &= ~( _BV( UDRE ) );
 d5c:	55 98       	cbi	0x0a, 5	; 10
 d5e:	08 95       	ret

00000d60 <xMBPortSerialInit>:
    }
}

BOOL
xMBPortSerialInit( UCHAR ucPORT, ULONG ulBaudRate, UCHAR ucDataBits, eMBParity eParity )
{
 d60:	cf 92       	push	r12
 d62:	df 92       	push	r13
 d64:	ef 92       	push	r14
 d66:	ff 92       	push	r15
 d68:	0f 93       	push	r16
 d6a:	1f 93       	push	r17
 d6c:	6a 01       	movw	r12, r20
 d6e:	7b 01       	movw	r14, r22
 d70:	12 2f       	mov	r17, r18
    UCHAR ucUCSRC = 0;

    /* prevent compiler warning. */
    (void)ucPORT;
	
    UBRR = UART_BAUD_CALC( ulBaudRate, F_CPU );
 d72:	84 e0       	ldi	r24, 0x04	; 4
 d74:	cc 0c       	add	r12, r12
 d76:	dd 1c       	adc	r13, r13
 d78:	ee 1c       	adc	r14, r14
 d7a:	ff 1c       	adc	r15, r15
 d7c:	8a 95       	dec	r24
 d7e:	d1 f7       	brne	.-12     	; 0xd74 <xMBPortSerialInit+0x14>
 d80:	60 e0       	ldi	r22, 0x00	; 0
 d82:	70 e8       	ldi	r23, 0x80	; 128
 d84:	80 e7       	ldi	r24, 0x70	; 112
 d86:	90 e0       	ldi	r25, 0x00	; 0
 d88:	a7 01       	movw	r20, r14
 d8a:	96 01       	movw	r18, r12
 d8c:	0e 94 c6 07 	call	0xf8c	; 0xf8c <__udivmodsi4>
 d90:	21 50       	subi	r18, 0x01	; 1
 d92:	29 b9       	out	0x09, r18	; 9
 d94:	03 30       	cpi	r16, 0x03	; 3
 d96:	30 f4       	brcc	.+12     	; 0xda4 <xMBPortSerialInit+0x44>
 d98:	e0 2f       	mov	r30, r16
 d9a:	f0 e0       	ldi	r31, 0x00	; 0
 d9c:	e7 56       	subi	r30, 0x67	; 103
 d9e:	ff 4f       	sbci	r31, 0xFF	; 255
 da0:	80 81       	ld	r24, Z
 da2:	01 c0       	rjmp	.+2      	; 0xda6 <xMBPortSerialInit+0x46>
 da4:	80 e0       	ldi	r24, 0x00	; 0
            break;
        case MB_PAR_NONE:
            break;
    }

    switch ( ucDataBits )
 da6:	17 30       	cpi	r17, 0x07	; 7
 da8:	21 f0       	breq	.+8      	; 0xdb2 <xMBPortSerialInit+0x52>
 daa:	18 30       	cpi	r17, 0x08	; 8
 dac:	19 f4       	brne	.+6      	; 0xdb4 <xMBPortSerialInit+0x54>
    {
        case 8:
            ucUCSRC |= _BV( UCSZ0 ) | _BV( UCSZ1 );
 dae:	86 60       	ori	r24, 0x06	; 6
            break;
 db0:	01 c0       	rjmp	.+2      	; 0xdb4 <xMBPortSerialInit+0x54>
        case 7:
            ucUCSRC |= _BV( UCSZ1 );
 db2:	84 60       	ori	r24, 0x04	; 4
#elif defined (__AVR_ATmega169__)
    UCSRC |= ucUCSRC;
#elif defined (__AVR_ATmega8__)
    UCSRC = _BV( URSEL ) | ucUCSRC;
#elif defined (__AVR_ATmega16__)
    UCSRC = _BV( URSEL ) | ucUCSRC;
 db4:	80 68       	ori	r24, 0x80	; 128
 db6:	80 bd       	out	0x20, r24	; 32
    UCSRC = _BV( URSEL ) | ucUCSRC;
#elif defined (__AVR_ATmega128__)
    UCSRC |= ucUCSRC;
#endif

    vMBPortSerialEnable( FALSE, FALSE );
 db8:	80 e0       	ldi	r24, 0x00	; 0
 dba:	60 e0       	ldi	r22, 0x00	; 0
 dbc:	0e 94 9c 06 	call	0xd38	; 0xd38 <vMBPortSerialEnable>

#ifdef RTS_ENABLE
    RTS_INIT;
 dc0:	8a 9a       	sbi	0x11, 2	; 17
 dc2:	92 98       	cbi	0x12, 2	; 18
#endif
    return TRUE;
}
 dc4:	81 e0       	ldi	r24, 0x01	; 1
 dc6:	1f 91       	pop	r17
 dc8:	0f 91       	pop	r16
 dca:	ff 90       	pop	r15
 dcc:	ef 90       	pop	r14
 dce:	df 90       	pop	r13
 dd0:	cf 90       	pop	r12
 dd2:	08 95       	ret

00000dd4 <xMBPortSerialPutByte>:

BOOL
xMBPortSerialPutByte( CHAR ucByte )
{
    UDR = ucByte;
 dd4:	8c b9       	out	0x0c, r24	; 12
    return TRUE;
}
 dd6:	81 e0       	ldi	r24, 0x01	; 1
 dd8:	08 95       	ret

00000dda <xMBPortSerialGetByte>:

BOOL
xMBPortSerialGetByte( CHAR * pucByte )
{
    *pucByte = UDR;
 dda:	2c b1       	in	r18, 0x0c	; 12
 ddc:	fc 01       	movw	r30, r24
 dde:	20 83       	st	Z, r18
    return TRUE;
}
 de0:	81 e0       	ldi	r24, 0x01	; 1
 de2:	08 95       	ret

00000de4 <__vector_12>:

SIGNAL( SIG_USART_DATA )
{
 de4:	1f 92       	push	r1
 de6:	0f 92       	push	r0
 de8:	0f b6       	in	r0, 0x3f	; 63
 dea:	0f 92       	push	r0
 dec:	11 24       	eor	r1, r1
 dee:	2f 93       	push	r18
 df0:	3f 93       	push	r19
 df2:	4f 93       	push	r20
 df4:	5f 93       	push	r21
 df6:	6f 93       	push	r22
 df8:	7f 93       	push	r23
 dfa:	8f 93       	push	r24
 dfc:	9f 93       	push	r25
 dfe:	af 93       	push	r26
 e00:	bf 93       	push	r27
 e02:	ef 93       	push	r30
 e04:	ff 93       	push	r31
    pxMBFrameCBTransmitterEmpty(  );
 e06:	e0 91 3f 01 	lds	r30, 0x013F
 e0a:	f0 91 40 01 	lds	r31, 0x0140
 e0e:	09 95       	icall
}
 e10:	ff 91       	pop	r31
 e12:	ef 91       	pop	r30
 e14:	bf 91       	pop	r27
 e16:	af 91       	pop	r26
 e18:	9f 91       	pop	r25
 e1a:	8f 91       	pop	r24
 e1c:	7f 91       	pop	r23
 e1e:	6f 91       	pop	r22
 e20:	5f 91       	pop	r21
 e22:	4f 91       	pop	r20
 e24:	3f 91       	pop	r19
 e26:	2f 91       	pop	r18
 e28:	0f 90       	pop	r0
 e2a:	0f be       	out	0x3f, r0	; 63
 e2c:	0f 90       	pop	r0
 e2e:	1f 90       	pop	r1
 e30:	18 95       	reti

00000e32 <__vector_11>:

SIGNAL( SIG_USART_RECV )
{
 e32:	1f 92       	push	r1
 e34:	0f 92       	push	r0
 e36:	0f b6       	in	r0, 0x3f	; 63
 e38:	0f 92       	push	r0
 e3a:	11 24       	eor	r1, r1
 e3c:	2f 93       	push	r18
 e3e:	3f 93       	push	r19
 e40:	4f 93       	push	r20
 e42:	5f 93       	push	r21
 e44:	6f 93       	push	r22
 e46:	7f 93       	push	r23
 e48:	8f 93       	push	r24
 e4a:	9f 93       	push	r25
 e4c:	af 93       	push	r26
 e4e:	bf 93       	push	r27
 e50:	ef 93       	push	r30
 e52:	ff 93       	push	r31
    pxMBFrameCBByteReceived(  );
 e54:	e0 91 43 01 	lds	r30, 0x0143
 e58:	f0 91 44 01 	lds	r31, 0x0144
 e5c:	09 95       	icall
}
 e5e:	ff 91       	pop	r31
 e60:	ef 91       	pop	r30
 e62:	bf 91       	pop	r27
 e64:	af 91       	pop	r26
 e66:	9f 91       	pop	r25
 e68:	8f 91       	pop	r24
 e6a:	7f 91       	pop	r23
 e6c:	6f 91       	pop	r22
 e6e:	5f 91       	pop	r21
 e70:	4f 91       	pop	r20
 e72:	3f 91       	pop	r19
 e74:	2f 91       	pop	r18
 e76:	0f 90       	pop	r0
 e78:	0f be       	out	0x3f, r0	; 63
 e7a:	0f 90       	pop	r0
 e7c:	1f 90       	pop	r1
 e7e:	18 95       	reti

00000e80 <__vector_13>:

#ifdef RTS_ENABLE
SIGNAL( SIG_UART_TRANS )
{
 e80:	1f 92       	push	r1
 e82:	0f 92       	push	r0
 e84:	0f b6       	in	r0, 0x3f	; 63
 e86:	0f 92       	push	r0
 e88:	11 24       	eor	r1, r1
    RTS_LOW;
 e8a:	92 98       	cbi	0x12, 2	; 18
}
 e8c:	0f 90       	pop	r0
 e8e:	0f be       	out	0x3f, r0	; 63
 e90:	0f 90       	pop	r0
 e92:	1f 90       	pop	r1
 e94:	18 95       	reti

00000e96 <vMBPortTimersEnable>:


inline void
vMBPortTimersEnable(  )
{
    TCNT1 = 0x0000;
 e96:	1d bc       	out	0x2d, r1	; 45
 e98:	1c bc       	out	0x2c, r1	; 44
    if( usTimerOCRADelta > 0 )
 e9a:	80 91 3d 01 	lds	r24, 0x013D
 e9e:	90 91 3e 01 	lds	r25, 0x013E
 ea2:	00 97       	sbiw	r24, 0x00	; 0
 ea4:	29 f0       	breq	.+10     	; 0xeb0 <vMBPortTimersEnable+0x1a>
    {
        TIMSK1 |= _BV( OCIE1A );
 ea6:	29 b7       	in	r18, 0x39	; 57
 ea8:	20 61       	ori	r18, 0x10	; 16
 eaa:	29 bf       	out	0x39, r18	; 57
        OCR1A = usTimerOCRADelta;
 eac:	9b bd       	out	0x2b, r25	; 43
 eae:	8a bd       	out	0x2a, r24	; 42
    }

    TCCR1B |= _BV( CS12 ) | _BV( CS10 );
 eb0:	8e b5       	in	r24, 0x2e	; 46
 eb2:	85 60       	ori	r24, 0x05	; 5
 eb4:	8e bd       	out	0x2e, r24	; 46
}
 eb6:	08 95       	ret

00000eb8 <vMBPortTimersDisable>:

inline void
vMBPortTimersDisable(  )
{
    /* Disable the timer. */
    TCCR1B &= ~( _BV( CS12 ) | _BV( CS10 ) );
 eb8:	8e b5       	in	r24, 0x2e	; 46
 eba:	8a 7f       	andi	r24, 0xFA	; 250
 ebc:	8e bd       	out	0x2e, r24	; 46
    /* Disable the output compare interrupts for channel A/B. */
    TIMSK1 &= ~( _BV( OCIE1A ) );
 ebe:	89 b7       	in	r24, 0x39	; 57
 ec0:	8f 7e       	andi	r24, 0xEF	; 239
 ec2:	89 bf       	out	0x39, r24	; 57
    /* Clear output compare flags for channel A/B. */
    TIFR1 |= _BV( OCF1A ) ;
 ec4:	88 b7       	in	r24, 0x38	; 56
 ec6:	80 61       	ori	r24, 0x10	; 16
 ec8:	88 bf       	out	0x38, r24	; 56
}
 eca:	08 95       	ret

00000ecc <xMBPortTimersInit>:
BOOL
xMBPortTimersInit( USHORT usTim1Timerout50us )
{
    /* Calculate overflow counter an OCR values for Timer1. */
    usTimerOCRADelta =
        ( MB_TIMER_TICKS * usTim1Timerout50us ) / ( MB_50US_TICKS );
 ecc:	bc 01       	movw	r22, r24
 ece:	80 e0       	ldi	r24, 0x00	; 0
 ed0:	90 e0       	ldi	r25, 0x00	; 0
 ed2:	20 e2       	ldi	r18, 0x20	; 32
 ed4:	3c e1       	ldi	r19, 0x1C	; 28
 ed6:	40 e0       	ldi	r20, 0x00	; 0
 ed8:	50 e0       	ldi	r21, 0x00	; 0
 eda:	0e 94 a7 07 	call	0xf4e	; 0xf4e <__mulsi3>
 ede:	20 e2       	ldi	r18, 0x20	; 32
 ee0:	3e e4       	ldi	r19, 0x4E	; 78
 ee2:	40 e0       	ldi	r20, 0x00	; 0
 ee4:	50 e0       	ldi	r21, 0x00	; 0
 ee6:	0e 94 c6 07 	call	0xf8c	; 0xf8c <__udivmodsi4>
/* ----------------------- Start implementation -----------------------------*/
BOOL
xMBPortTimersInit( USHORT usTim1Timerout50us )
{
    /* Calculate overflow counter an OCR values for Timer1. */
    usTimerOCRADelta =
 eea:	30 93 3e 01 	sts	0x013E, r19
 eee:	20 93 3d 01 	sts	0x013D, r18
        ( MB_TIMER_TICKS * usTim1Timerout50us ) / ( MB_50US_TICKS );

    TCCR1A = 0x00;
 ef2:	1f bc       	out	0x2f, r1	; 47
    TCCR1B = 0x00;
 ef4:	1e bc       	out	0x2e, r1	; 46
    TCCR1C = 0x00;
 ef6:	1f bc       	out	0x2f, r1	; 47

    vMBPortTimersDisable(  );
 ef8:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vMBPortTimersDisable>

    return TRUE;
}
 efc:	81 e0       	ldi	r24, 0x01	; 1
 efe:	08 95       	ret

00000f00 <__vector_6>:
    /* Clear output compare flags for channel A/B. */
    TIFR1 |= _BV( OCF1A ) ;
}

SIGNAL( SIG_OUTPUT_COMPARE1A )
{
 f00:	1f 92       	push	r1
 f02:	0f 92       	push	r0
 f04:	0f b6       	in	r0, 0x3f	; 63
 f06:	0f 92       	push	r0
 f08:	11 24       	eor	r1, r1
 f0a:	2f 93       	push	r18
 f0c:	3f 93       	push	r19
 f0e:	4f 93       	push	r20
 f10:	5f 93       	push	r21
 f12:	6f 93       	push	r22
 f14:	7f 93       	push	r23
 f16:	8f 93       	push	r24
 f18:	9f 93       	push	r25
 f1a:	af 93       	push	r26
 f1c:	bf 93       	push	r27
 f1e:	ef 93       	push	r30
 f20:	ff 93       	push	r31
    ( void )pxMBPortCBTimerExpired(  );
 f22:	e0 91 41 01 	lds	r30, 0x0141
 f26:	f0 91 42 01 	lds	r31, 0x0142
 f2a:	09 95       	icall
}
 f2c:	ff 91       	pop	r31
 f2e:	ef 91       	pop	r30
 f30:	bf 91       	pop	r27
 f32:	af 91       	pop	r26
 f34:	9f 91       	pop	r25
 f36:	8f 91       	pop	r24
 f38:	7f 91       	pop	r23
 f3a:	6f 91       	pop	r22
 f3c:	5f 91       	pop	r21
 f3e:	4f 91       	pop	r20
 f40:	3f 91       	pop	r19
 f42:	2f 91       	pop	r18
 f44:	0f 90       	pop	r0
 f46:	0f be       	out	0x3f, r0	; 63
 f48:	0f 90       	pop	r0
 f4a:	1f 90       	pop	r1
 f4c:	18 95       	reti

00000f4e <__mulsi3>:
 f4e:	62 9f       	mul	r22, r18
 f50:	d0 01       	movw	r26, r0
 f52:	73 9f       	mul	r23, r19
 f54:	f0 01       	movw	r30, r0
 f56:	82 9f       	mul	r24, r18
 f58:	e0 0d       	add	r30, r0
 f5a:	f1 1d       	adc	r31, r1
 f5c:	64 9f       	mul	r22, r20
 f5e:	e0 0d       	add	r30, r0
 f60:	f1 1d       	adc	r31, r1
 f62:	92 9f       	mul	r25, r18
 f64:	f0 0d       	add	r31, r0
 f66:	83 9f       	mul	r24, r19
 f68:	f0 0d       	add	r31, r0
 f6a:	74 9f       	mul	r23, r20
 f6c:	f0 0d       	add	r31, r0
 f6e:	65 9f       	mul	r22, r21
 f70:	f0 0d       	add	r31, r0
 f72:	99 27       	eor	r25, r25
 f74:	72 9f       	mul	r23, r18
 f76:	b0 0d       	add	r27, r0
 f78:	e1 1d       	adc	r30, r1
 f7a:	f9 1f       	adc	r31, r25
 f7c:	63 9f       	mul	r22, r19
 f7e:	b0 0d       	add	r27, r0
 f80:	e1 1d       	adc	r30, r1
 f82:	f9 1f       	adc	r31, r25
 f84:	bd 01       	movw	r22, r26
 f86:	cf 01       	movw	r24, r30
 f88:	11 24       	eor	r1, r1
 f8a:	08 95       	ret

00000f8c <__udivmodsi4>:
 f8c:	a1 e2       	ldi	r26, 0x21	; 33
 f8e:	1a 2e       	mov	r1, r26
 f90:	aa 1b       	sub	r26, r26
 f92:	bb 1b       	sub	r27, r27
 f94:	fd 01       	movw	r30, r26
 f96:	0d c0       	rjmp	.+26     	; 0xfb2 <__udivmodsi4_ep>

00000f98 <__udivmodsi4_loop>:
 f98:	aa 1f       	adc	r26, r26
 f9a:	bb 1f       	adc	r27, r27
 f9c:	ee 1f       	adc	r30, r30
 f9e:	ff 1f       	adc	r31, r31
 fa0:	a2 17       	cp	r26, r18
 fa2:	b3 07       	cpc	r27, r19
 fa4:	e4 07       	cpc	r30, r20
 fa6:	f5 07       	cpc	r31, r21
 fa8:	20 f0       	brcs	.+8      	; 0xfb2 <__udivmodsi4_ep>
 faa:	a2 1b       	sub	r26, r18
 fac:	b3 0b       	sbc	r27, r19
 fae:	e4 0b       	sbc	r30, r20
 fb0:	f5 0b       	sbc	r31, r21

00000fb2 <__udivmodsi4_ep>:
 fb2:	66 1f       	adc	r22, r22
 fb4:	77 1f       	adc	r23, r23
 fb6:	88 1f       	adc	r24, r24
 fb8:	99 1f       	adc	r25, r25
 fba:	1a 94       	dec	r1
 fbc:	69 f7       	brne	.-38     	; 0xf98 <__udivmodsi4_loop>
 fbe:	60 95       	com	r22
 fc0:	70 95       	com	r23
 fc2:	80 95       	com	r24
 fc4:	90 95       	com	r25
 fc6:	9b 01       	movw	r18, r22
 fc8:	ac 01       	movw	r20, r24
 fca:	bd 01       	movw	r22, r26
 fcc:	cf 01       	movw	r24, r30
 fce:	08 95       	ret

00000fd0 <_exit>:
 fd0:	f8 94       	cli

00000fd2 <__stop_program>:
 fd2:	ff cf       	rjmp	.-2      	; 0xfd2 <__stop_program>
